#MULTICAT_START
# dir: ./
# file: STATUS.md
# notes: Simplified UI—deterministic layout, fewer wrappers, smaller View
#MULTICAT_END
# Status

- UI: deterministic layout (no runtime text measurements)
- View: single pass render using computed Layout
- Styles: no wrapper types; direct use in view
- Init: uses textarea.Blink directly
- Model: resizeLayout uses pure function ComputeLayout
- Constants: fixed heights for header/footer/repl

#MULTICAT_START
# dir: ./internal/tui
# file: layout.go
# notes: Pure layout computation; removes lipgloss height probes
#MULTICAT_END
package tui

type Layout struct {
	HeaderH int
	FooterH int
	ReplH   int
	LeftW   int
	RightW  int
	PaneH   int
}

const (
	headerFixedH = 1
	footerFixedH = 1
	replFixedH   = 3
)

func ComputeLayout(totalW, totalH int) Layout {
	if totalW < 4 {
		totalW = 4
	}
	if totalH < 5 {
		totalH = 5
	}
	leftW := totalW / 3
	rightW := totalW - leftW
	paneH := totalH - headerFixedH - footerFixedH - replFixedH
	if paneH < 1 {
		paneH = 1
	}
	return Layout{
		HeaderH: headerFixedH,
		FooterH: footerFixedH,
		ReplH:   replFixedH,
		LeftW:   leftW,
		RightW:  rightW,
		PaneH:   paneH,
	}
}

#MULTICAT_START
# dir: ./internal/tui
# file: styles.go
# notes: Drop wrappers; keep only style construction and footer rendering
#MULTICAT_END
package tui

import (
	"strings"

	"github.com/charmbracelet/bubbles/textarea"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type Styles struct {
	header           lipgloss.Style
	footer           lipgloss.Style
	completion       lipgloss.Style
	paneBorder       lipgloss.Style
	paneBorderActive lipgloss.Style
	repl             lipgloss.Style
}

func buildStyles(m *Model) Styles {
	return Styles{
		header: lipgloss.NewStyle().
			Background(m.currentTheme.HeaderBg).
			Foreground(m.currentTheme.HeaderFg).
			Padding(0, 1),
		footer: lipgloss.NewStyle().
			Background(m.currentTheme.FooterBg).
			Foreground(m.currentTheme.FooterFg).
			Padding(0, 1),
		completion: lipgloss.NewStyle().
			Foreground(m.currentTheme.ComplFg),
		paneBorder: lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(m.currentTheme.PaneBorderInactive),
		paneBorderActive: lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(m.currentTheme.PaneBorderActive),
		repl: lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(m.currentTheme.PaneBorderActive),
	}
}

func (m *Model) renderFooter(s Styles, width int) string {
	var b strings.Builder
	b.WriteString(m.footerHelp)
	if len(m.suggestions) > 0 && m.activePane == replPane {
		b.WriteString(" | Suggest: ")
		b.WriteString(s.completion.Render(strings.Join(m.suggestions, ", ")))
	}
	return s.footer.Width(width).Render(b.String())
}

// Bubble Tea textarea blink, exposed as a Cmd factory.
func textBlink() func() tea.Msg { return textarea.Blink }

#MULTICAT_START
# dir: ./internal/tui
# file: model.go
# notes: Use ComputeLayout; remove lip* helpers
#MULTICAT_END
package tui

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/charmbracelet/bubbles/textarea"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
)

type pane int

const (
	leftPane pane = iota
	rightPane
	replPane
)

type serverLogMsg struct{ content string }
type mainLogMsg struct{ content string }

type Command struct {
	Name        string
	Description string
	Executor    func(m *Model, args []string) (string, error)
}

type Model struct {
	leftVP       viewport.Model
	rightVP      viewport.Model
	repl         textarea.Model
	activePane   pane
	leftContent  []string
	rightContent []string

	width  int
	height int

	commands   map[string]Command
	apiPort    string
	httpServer *http.Server
	program    *tea.Program

	themes       map[string]Theme
	currentTheme Theme
	themeName    string
	suggestions  []string
	footerHelp   string
}

func initialModel(port string) Model {
	leftContent := []string{
		"Welcome to Tubes!",
		"This is the primary log pane.",
	}

	themes := make(map[string]Theme)
	if th, err := loadTheme("dark_ocean.theme"); err != nil {
		leftContent = append(leftContent, "Warning: could not load dark_ocean.theme, using default.")
		themes["ocean"] = defaultTheme()
	} else {
		themes["ocean"] = th
	}
	if th, err := loadTheme("cyber_neon.theme"); err != nil {
		leftContent = append(leftContent, "Warning: could not load cyber_neon.theme, using default.")
		themes["neon"] = defaultTheme()
	} else {
		themes["neon"] = th
	}

	ta := textarea.New()
	ta.Placeholder = "Type a /command and press Enter..."
	ta.Focus()
	ta.Prompt = "┃ "
	ta.CharLimit = 280
	ta.SetHeight(1)
	ta.KeyMap.InsertNewline.SetEnabled(false)

	m := Model{
		repl:         ta,
		activePane:   replPane,
		themes:       themes,
		currentTheme: themes["ocean"],
		themeName:    "ocean",
		apiPort:      port,
		leftContent:  leftContent,
		rightContent: []string{"API Log", fmt.Sprintf("API server starting on port %s", port)},
		footerHelp:   "Tab: Cycle Panes | Up/Down: Scroll | Ctrl+C: Quit",
	}
	m.loadCommands()
	return m
}

func (m *Model) cyclePane() {
	m.activePane = (m.activePane + 1) % 3
	if m.activePane == replPane {
		m.repl.Focus()
	} else {
		m.repl.Blur()
	}
}

func (m *Model) handleInput() {
	input := strings.TrimSpace(m.repl.Value())
	if input == "" {
		return
	}
	m.leftContent = append(m.leftContent, "▶ "+input)
	parts := strings.Fields(input)
	cmdName := parts[0]
	args := parts[1:]
	if cmd, ok := m.commands[cmdName]; ok {
		result, err := cmd.Executor(m, args)
		if err != nil {
			m.leftContent = append(m.leftContent, "Error: "+err.Error())
		} else if result != "" {
			m.leftContent = append(m.leftContent, result)
		}
	} else {
		m.leftContent = append(m.leftContent, "Error: Unknown command '"+cmdName+"'")
	}
	m.repl.Reset()
	m.updateSuggestions()
	m.leftVP.SetContent(strings.Join(m.leftContent, "\n"))
	m.leftVP.GotoBottom()
}

func (m *Model) resizeLayout() {
	l := ComputeLayout(m.width, m.height)

	m.leftVP.Width = l.LeftW - 2
	m.leftVP.Height = l.PaneH
	m.leftVP.SetContent(strings.Join(m.leftContent, "\n"))

	m.rightVP.Width = l.RightW - 2
	m.rightVP.Height = l.PaneH
	m.rightVP.SetContent(strings.Join(m.rightContent, "\n"))

	m.repl.SetWidth(m.width - 2)
}

#MULTICAT_START
# dir: ./internal/tui
# file: view.go
# notes: Compact Init/Update/View; uses ComputeLayout and Styles
#MULTICAT_END
package tui

import (
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

func (m *Model) Init() tea.Cmd {
	return tea.Batch(textBlink(), m.startServerCmd())
}

func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.resizeLayout()

	case tea.KeyMsg:
		if m.activePane == replPane && msg.Type != tea.KeyEnter && msg.Type != tea.KeyTab {
			m.repl, cmd = m.repl.Update(msg)
			m.updateSuggestions()
			cmds = append(cmds, cmd)
		}
		switch msg.Type {
		case tea.KeyCtrlC, tea.KeyEsc:
			return m, tea.Sequence(m.shutdownServerCmd(), tea.Quit)
		case tea.KeyTab:
			if m.activePane == replPane {
				m.applySuggestion()
			} else {
				m.cyclePane()
			}
		case tea.KeyEnter:
			if m.activePane == replPane {
				m.handleInput()
			}
		default:
			if m.activePane != replPane {
				switch m.activePane {
				case leftPane:
					m.leftVP, cmd = m.leftVP.Update(msg)
					cmds = append(cmds, cmd)
				case rightPane:
					m.rightVP, cmd = m.rightVP.Update(msg)
					cmds = append(cmds, cmd)
				}
			}
		}

	case serverLogMsg:
		m.rightContent = append(m.rightContent, msg.content)
		m.rightVP.SetContent(joinLines(m.rightContent))
		m.rightVP.GotoBottom()

	case mainLogMsg:
		m.leftContent = append(m.leftContent, msg.content)
		m.leftVP.SetContent(joinLines(m.leftContent))
		m.leftVP.GotoBottom()
	}
	return m, tea.Batch(cmds...)
}

func (m *Model) View() string {
	if m.width == 0 {
		return "Initializing..."
	}
	s := buildStyles(m)
	l := ComputeLayout(m.width, m.height)

	header := s.header.Width(m.width).Render("Tubes")
	footer := m.renderFooter(s, m.width)

	leftPaneStyle := s.paneBorder
	rightPaneStyle := s.paneBorder
	if m.activePane == leftPane {
		leftPaneStyle = s.paneBorderActive
	}
	if m.activePane == rightPane {
		rightPaneStyle = s.paneBorderActive
	}

	left := leftPaneStyle.
		Width(l.LeftW - 2).
		Height(l.PaneH).
		Render(m.leftVP.View())

	right := rightPaneStyle.
		Width(l.RightW - 2).
		Height(l.PaneH).
		Render(m.rightVP.View())

	content := lipgloss.JoinHorizontal(lipgloss.Top, left, right)
	repl := s.repl.Width(m.width - 2).Render(m.repl.View())

	return lipgloss.JoinVertical(lipgloss.Left, header, content, repl, footer)
}

#MULTICAT_START
# dir: ./internal/tui
# file: util.go
# notes: Small helpers used across files
#MULTICAT_END
package tui

import "strings"

func joinLines(xs []string) string { return strings.Join(xs, "\n") }
