# Tubes HTTP API Server

**Document**: `docs/api/001.md`  
**Purpose**: Complete documentation of Tubes' web server and REST API

---

## Architecture Overview

Tubes runs a built-in HTTP server alongside the TUI, demonstrating **CLI/API parity**. Every command available via `/command` syntax is also accessible through REST endpoints.

### Server Location
- **Implementation**: `internal/tui/server.go`
- **Startup**: `model.go:405` - `m.startServerCmd()`
- **Default Port**: `8080` (configurable via `-port` flag)

## API Design Principles

### 1. CLI/API Parity  
Every TUI command has a corresponding API endpoint:
```bash
# TUI Command
/ui split 0.3

# API Equivalent  
POST /api/ui
{"action": "split", "ratio": 0.3}
```

### 2. RESTful Design
Standard HTTP methods and status codes:
- `GET` - Read operations
- `POST` - Create/Execute operations  
- `PUT` - Update operations (future)
- `DELETE` - Remove operations (future)

### 3. JSON-First
All request/response bodies use JSON for consistency and tooling compatibility.

## Current Endpoints

### 1. API Discovery
**Endpoint**: `GET /api/list`  
**Purpose**: Enumerate available API endpoints

```bash
curl http://localhost:8080/api/list
```

**Response**:
```json
{
  "description": "/api/list, /fzf/api, POST /log",
  "version": "1.0",
  "endpoints": [
    {
      "path": "/api/list",
      "method": "GET", 
      "description": "List available endpoints"
    },
    {
      "path": "/fzf/api",
      "method": "GET",
      "description": "Fuzzy finder integration status"
    },
    {
      "path": "/log", 
      "method": "POST",
      "description": "Send log messages to TUI"
    }
  ]
}
```

### 2. Logging Integration
**Endpoint**: `POST /log`  
**Purpose**: Send messages to the TUI's left panel

```bash
curl -X POST http://localhost:8080/log \
  -H "Content-Type: application/json" \
  -d '{"message": "Hello from API!"}'
```

**Request Body**:
```json
{
  "message": "Log message content"
}
```

**Response**:
```json
{
  "status": "logged",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### 3. FZF Integration Status  
**Endpoint**: `GET /fzf/api`  
**Purpose**: Check fuzzy finder integration status

```bash
curl http://localhost:8080/fzf/api
```

**Response**:
```json
{
  "description": "fzf: no integration configured",
  "status": "disabled"
}
```

## Planned Endpoints

### Command Execution
**Endpoint**: `POST /api/command`  
**Purpose**: Execute any TUI command remotely

```bash
curl -X POST http://localhost:8080/api/command \
  -H "Content-Type: application/json" \
  -d '{"command": "/ui split 0.3"}'
```

### State Management  
**Endpoint**: `GET /api/state`  
**Purpose**: Retrieve current application state

```bash
curl http://localhost:8080/api/state
```

**Response**:
```json
{
  "ui": {
    "activePane": "left",
    "colRatio": 0.38,
    "width": 120,
    "height": 40
  },
  "domain": {
    "mode": "self",
    "selectedPath": "internal/tui/model.go"
  }
}
```

### File Operations
**Endpoint**: `POST /api/open`  
**Purpose**: Open files (equivalent to `/open` command)

```bash
curl -X POST http://localhost:8080/api/open \
  -H "Content-Type: application/json" \
  -d '{"path": "docs/api/001.md"}'
```

## Server Implementation

### Startup Process
```go
// Location: internal/tui/server.go:14
func (m *Model) startServerCmd() tea.Cmd {
    return func() tea.Msg {
        mux := http.NewServeMux()
        
        // Register handlers
        mux.HandleFunc("/api/list", m.handleAPIList)
        mux.HandleFunc("/log", m.handleLog)
        mux.HandleFunc("/fzf/api", m.handleFZF)
        
        // Start server
        m.httpServer = &http.Server{
            Addr:    ":" + m.apiPort,
            Handler: mux,
        }
        
        return m.httpServer.ListenAndServe()
    }
}
```

### Handler Pattern
```go
func (m *Model) handleAPIList(w http.ResponseWriter, r *http.Request) {
    // Log the request
    m.enqueueLog(logToLeft, fmt.Sprintf("[%s] GET /api/list", 
        time.Now().Format("15:04:05")))
    
    // Set headers
    w.Header().Set("Content-Type", "application/json")
    
    // Execute corresponding command
    if result, err := m.commands["/api"].Executor(m, nil); err == nil {
        json.NewEncoder(w).Encode(map[string]string{
            "description": result,
        })
    }
}
```

### Non-Blocking Logging
The server uses async logging to avoid blocking the TUI:

```go
// Location: internal/tui/server.go:20
func (m *Model) enqueueLog(target logTarget, content string) {
    select {
    case m.logCh <- logEntry{target: target, content: content}:
        // Message queued successfully
    default:
        // Channel full, drop message to prevent blocking
    }
}
```

## Security Considerations

### Current Status: Development Only
⚠️ **The current API has no authentication and should only be used in development.**

### Future Security Features
- **API Keys**: Simple token-based authentication
- **CORS**: Configurable cross-origin policies  
- **Rate Limiting**: Prevent API abuse
- **TLS**: HTTPS support for production use

```go
// Future: API authentication
type APIKey struct {
    Key     string    `json:"key"`
    Created time.Time `json:"created"`
    Scopes  []string  `json:"scopes"`
}
```

## Integration Examples

### Shell Scripts
```bash
#!/bin/bash
# Send build results to Tubes
tubes_log() {
    curl -s -X POST http://localhost:8080/log \
      -H "Content-Type: application/json" \
      -d "{\"message\": \"$1\"}"
}

tubes_log "Starting build..."
go build ./... && tubes_log "Build successful!" || tubes_log "Build failed!"
```

### JavaScript/Node.js
```javascript
class TubesAPI {
    constructor(baseURL = 'http://localhost:8080') {
        this.baseURL = baseURL;
    }
    
    async log(message) {
        return fetch(`${this.baseURL}/log`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({message})
        });
    }
    
    async executeCommand(command) {
        return fetch(`${this.baseURL}/api/command`, {
            method: 'POST', 
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command})
        });
    }
}
```

### Python Integration
```python
import requests
import json

class TubesClient:
    def __init__(self, base_url="http://localhost:8080"):
        self.base_url = base_url
    
    def log(self, message):
        return requests.post(f"{self.base_url}/log", 
                           json={"message": message})
    
    def get_state(self):
        return requests.get(f"{self.base_url}/api/state").json()
```

## Monitoring and Debugging

### Server Logs
All API requests are logged to the TUI's left panel with timestamps:
```
[10:30:15] GET /api/list
[10:30:22] POST /log - msg: 'Build completed'
[10:30:45] GET /fzf/api
```

### Health Check
```bash
curl -f http://localhost:8080/api/list || echo "Server down"
```

### API Testing
```bash
# Test all endpoints
for endpoint in "/api/list" "/fzf/api"; do
    echo "Testing $endpoint"
    curl -s "http://localhost:8080$endpoint" | jq .
done
```

This API design enables Tubes to be both a standalone TUI and a programmable service, supporting automation, integration, and remote control scenarios.

---

**See Also**: [../tea/001.md - Redux Architecture](../tea/001.md)  
**Next**: Integration examples and client libraries