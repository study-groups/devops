# State Management Patterns in Tubes

**Document**: `docs/tea/003.md`  
**Purpose**: Advanced Redux-like state management techniques in Tubes

---

## State Structure Design

### Current Model Structure
```go
// Location: internal/tui/model.go:38-89
type Model struct {
    // UI Layer State
    leftVP       viewport.Model
    rightVP      viewport.Model  
    repl         textarea.Model
    activePane   pane
    
    // Layout State
    width, height int
    col1Ratio     float64
    headerH, cliH, statusH, footerH int
    
    // Domain State  
    curMode       mode
    projectRoot   string
    tubesDir      string
    selectedPath  string
    lastCompile   string
    
    // Application State
    commands      map[string]Command
    suggestions   []string
    themes        map[string]Theme
}
```

### Redux-Inspired State Slicing

A better approach would separate concerns:

```go
type AppState struct {
    UI       UIState       `json:"ui"`
    Domain   DomainState   `json:"domain"`  
    Session  SessionState  `json:"session"`
    Commands CommandState  `json:"commands"`
}

type UIState struct {
    ActivePane   string    `json:"activePane"`
    Layout       Layout    `json:"layout"`
    Theme        string    `json:"theme"`
    Suggestions  []string  `json:"suggestions"`
}

type DomainState struct {
    Mode         string    `json:"mode"`
    SelectedPath string    `json:"selectedPath"`
    ProjectRoot  string    `json:"projectRoot"`
    TubesDir     string    `json:"tubesDir"`
}
```

## State Management Patterns

### 1. Immutable Updates

#### Current Approach (Mutating)
```go
// ❌ Direct mutation
mm.col1Ratio = ratio
mm.activePane = nextPane
```

#### Redux Approach (Immutable)
```go
// ✅ Create new state
func (m Model) withColRatio(ratio float64) Model {
    return Model{
        ...m,  // Copy all fields
        col1Ratio: ratio,  // Update specific field
    }
}

// In Update():
return m.withColRatio(0.3), nil
```

### 2. State Composition

Break large state into composable pieces:

```go
type Model struct {
    ui       UIState
    domain   DomainState  
    session  SessionState
}

func (m Model) UpdateUI(fn func(UIState) UIState) Model {
    return Model{
        ...m,
        ui: fn(m.ui),
    }
}

// Usage:
return m.UpdateUI(func(ui UIState) UIState {
    return ui.WithActivePane("left")
}), nil
```

### 3. State Validation

Ensure state consistency:

```go
type StateValidator interface {
    Validate() error
}

func (m Model) Validate() error {
    if m.col1Ratio < 0.1 || m.col1Ratio > 0.9 {
        return errors.New("invalid column ratio")
    }
    return nil
}
```

### 4. State Persistence

Redux DevTools-like functionality:

```go
type StateHistory struct {
    states   []Model
    position int
}

func (h *StateHistory) Push(m Model) {
    h.states = append(h.states, m)
    h.position = len(h.states) - 1
}

func (h *StateHistory) Undo() Model {
    if h.position > 0 {
        h.position--
    }
    return h.states[h.position]
}
```

## Derived State (Selectors)

Compute derived values from base state:

```go
// Base state
type Model struct {
    width     int
    col1Ratio float64
}

// Derived state (like Redux selectors)
func (m Model) LeftWidth() int {
    return int(float64(m.width) * m.col1Ratio)
}

func (m Model) RightWidth() int {
    return m.width - m.LeftWidth() - 1  // -1 for divider
}

func (m Model) IsNarrowLayout() bool {
    return m.width < 80
}
```

## State Normalization

For complex data, normalize like Redux:

### Denormalized (Current)
```go
type Model struct {
    leftContent []string  // Mixed content types
}
```

### Normalized (Better)
```go
type ContentState struct {
    Items    map[string]ContentItem  `json:"items"`
    Lists    map[string][]string     `json:"lists"`  
    Current  string                  `json:"current"`
}

type ContentItem struct {
    ID   string `json:"id"`
    Type string `json:"type"`  // "file", "directory", "help"
    Data string `json:"data"`
}
```

## State Hydration/Dehydration

Save/load state for persistence:

```go
func (m Model) Serialize() ([]byte, error) {
    state := SerializableState{
        Mode:         string(m.curMode),
        SelectedPath: m.selectedPath,
        ColRatio:     m.col1Ratio,
        Theme:        m.themeName,
    }
    return json.Marshal(state)
}

func DeserializeModel(data []byte) (Model, error) {
    var state SerializableState
    if err := json.Unmarshal(data, &state); err != nil {
        return Model{}, err
    }
    
    // Reconstruct model from serialized state
    return buildModelFromState(state), nil
}
```

## Middleware Pattern

Intercept and transform messages:

```go
type Middleware func(Model, tea.Msg) (Model, tea.Msg, tea.Cmd)

func LoggingMiddleware(m Model, msg tea.Msg) (Model, tea.Msg, tea.Cmd) {
    log.Printf("Message: %T %+v", msg, msg)
    return m, msg, nil  // Pass through unchanged
}

func ValidationMiddleware(m Model, msg tea.Msg) (Model, tea.Msg, tea.Cmd) {
    // Validate message before processing
    if err := validateMessage(msg); err != nil {
        return m, nil, nil  // Reject invalid message
    }
    return m, msg, nil
}
```

## Time-Travel Debugging

Implement Redux DevTools-like functionality:

```go
type DevTools struct {
    history   []StateSnapshot
    position  int
    recording bool
}

type StateSnapshot struct {
    State   Model     `json:"state"`
    Message tea.Msg   `json:"message"`  
    Time    time.Time `json:"time"`
}

func (d *DevTools) Record(m Model, msg tea.Msg) {
    if d.recording {
        snapshot := StateSnapshot{
            State:   m,
            Message: msg,
            Time:    time.Now(),
        }
        d.history = append(d.history, snapshot)
    }
}
```

## Benefits of Redux Patterns

### 1. Predictable State Updates
Every state change follows the same pattern: `(state, action) → newState`

### 2. Easy Testing  
```go
func TestUIStateUpdate(t *testing.T) {
    initial := UIState{ActivePane: "left"}
    updated := initial.WithActivePane("right")
    assert.Equal(t, "right", updated.ActivePane)
}
```

### 3. Time Travel
Replay any sequence of actions to debug issues.

### 4. Hot Reloading
Preserve state while reloading code.

### 5. State Inspection
Serialize state for debugging and monitoring.

---

**Previous**: [002.md - Actions and Message Handling](./002.md)  
**See Also**: [../api/001.md - HTTP API Integration](../api/001.md)