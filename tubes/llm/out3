#MULTICAT_START
# dir: ./
# file: STATUS.md
# notes: Refactor to semantic layout with dynamic sizing and modes (self|tasks)
#MULTICAT_END
# Status

- Layout: header | (col1|col2) | cli | status | footer
- Dynamic sizing: column ratio and row heights adjustable via commands
- Modes: `self` (project tree + source/markdown view), `tasks` (TUBES_DIR task tree + module view)
- Flow types (go): `llm-ask`, `llm-apply`, `compile`, `test`, `llm-commit`, `llm-reset`
- Config: `project.tubes` in repo root; tasks under `$TUBES_DIR/<tube-task-types>/`
- Key commands: `/mode`, `/open`, `/resize`, `/run`, `/help`

#MULTICAT_START
# dir: ./
# file: go.mod
# notes: add glamour for Markdown rendering; bubbles already present
#MULTICAT_END
module tubes

go 1.23.0

toolchain go1.24.6

require (
	github.com/charmbracelet/bubbles v0.21.0
	github.com/charmbracelet/bubbletea v1.3.6
	github.com/charmbracelet/glamour v0.6.0
	github.com/charmbracelet/lipgloss v1.1.0
	github.com/joho/godotenv v1.5.1
)

require (
	github.com/atotto/clipboard v0.1.4 // indirect
	github.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect
	github.com/charmbracelet/colorprofile v0.2.3-0.20250311203215-f60798e515dc // indirect
	github.com/charmbracelet/x/ansi v0.9.3 // indirect
	github.com/charmbracelet/x/cellbuf v0.0.13-0.20250311204145-2c3ea96c31dd // indirect
	github.com/charmbracelet/x/term v0.2.1 // indirect
	github.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect
	github.com/lucasb-eyer/go-colorful v1.2.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-localereader v0.0.1 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect
	github.com/muesli/cancelreader v0.2.2 // indirect
	github.com/muesli/termenv v0.16.0 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
	golang.org/x/sync v0.15.0 // indirect
	golang.org/x/sys v0.33.0 // indirect
	golang.org/x/text v0.3.8 // indirect
)

#MULTICAT_START
# dir: ./cmd/tubes
# file: main.go
# notes: unchanged entrypoint; runs TUI app
#MULTICAT_END
package main

import (
	"flag"
	"log"
	"os"

	"tubes/internal/tui"
)

func main() {
	f, err := os.OpenFile("tubes.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if err != nil {
		log.Fatalf("error opening file: %v", err)
	}
	defer f.Close()
	log.SetOutput(f)

	port := flag.String("port", "8080", "Port for the API server")
	flag.Parse()

	app := tui.New(*port)
	if err := app.Run(); err != nil {
		log.Fatalf("Error running Tubes: %v", err)
	}
}

#MULTICAT_START
# dir: ./internal/tui
# file: app.go
# notes: App wrapper
#MULTICAT_END
package tui

import tea "github.com/charmbracelet/bubbletea"

type App struct {
	model   *Model
	program *tea.Program
}

func New(port string) *App {
	m := initialModel(port)
	return &App{model: &m}
}

func (a *App) Run() error {
	p := tea.NewProgram(
		a.model,
		tea.WithAltScreen(),
		tea.WithMouseCellMotion(),
	)
	a.program = p
	a.model.program = p
	_, err := p.Run()
	return err
}

#MULTICAT_START
# dir: ./internal/tui
# file: layout.go
# notes: semantic layout with dynamic ratios/heights
#MULTICAT_END
package tui

type Layout struct {
	HeaderH int
	FooterH int
	CliH    int
	StatusH int
	LeftW   int
	RightW  int
	ColsH   int
}

func (m *Model) computeLayout() Layout {
	totalW, totalH := m.width, m.height
	if totalW < 10 {
		totalW = 10
	}
	minBands := m.headerH + m.cliH + m.statusH + m.footerH
	colsH := totalH - minBands
	if colsH < 3 {
		colsH = 3
	}
	leftW := int(float64(totalW) * m.col1Ratio)
	if leftW < 10 {
		leftW = 10
	}
	if leftW > totalW-10 {
		leftW = totalW - 10
	}
	return Layout{
		HeaderH: m.headerH,
		FooterH: m.footerH,
		CliH:    m.cliH,
		StatusH: m.statusH,
		LeftW:   leftW,
		RightW:  totalW - leftW,
		ColsH:   colsH,
	}
}

#MULTICAT_START
# dir: ./internal/tui
# file: theme.go
# notes: Theme types and loaders
#MULTICAT_END
package tui

import (
	"github.com/charmbracelet/lipgloss"
	"github.com/joho/godotenv"
)

type Theme struct {
	HeaderBg lipgloss.Color
	HeaderFg lipgloss.Color

	PaneBorderActive   lipgloss.Color
	PaneBorderInactive lipgloss.Color

	FooterBg lipgloss.Color
	FooterFg lipgloss.Color
	ComplFg  lipgloss.Color
}

func defaultTheme() Theme {
	return Theme{
		HeaderBg:           lipgloss.Color("#30343F"),
		HeaderFg:           lipgloss.Color("#FFFFFF"),
		PaneBorderActive:   lipgloss.Color("#AD58B4"),
		PaneBorderInactive: lipgloss.Color("#555555"),
		FooterBg:           lipgloss.Color("#22262E"),
		FooterFg:           lipgloss.Color("#DDDDDD"),
		ComplFg:            lipgloss.Color("#00ADD8"),
	}
}

func loadTheme(path string) (Theme, error) {
	env, err := godotenv.Read(path)
	if err != nil {
		return Theme{}, err
	}
	return Theme{
		HeaderBg:           lipgloss.Color(env["HEADER_BG"]),
		HeaderFg:           lipgloss.Color(env["HEADER_FG"]),
		PaneBorderActive:   lipgloss.Color(env["PANE_BORDER_ACTIVE"]),
		PaneBorderInactive: lipgloss.Color(env["PANE_BORDER_INACTIVE"]),
		FooterBg:           lipgloss.Color(env["FOOTER_BG"]),
		FooterFg:           lipgloss.Color(env["FOOTER_FG"]),
		ComplFg:            lipgloss.Color(env["COMPL_FG"]),
	}, nil
}

#MULTICAT_START
# dir: ./internal/tui
# file: styles.go
# notes: styles + footer rendering + blink cmd
#MULTICAT_END
package tui

import (
	"strings"

	"github.com/charmbracelet/bubbles/textarea"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

type Styles struct {
	header    lipgloss.Style
	colsWrap  lipgloss.Style
	colBox    lipgloss.Style
	colBoxAct lipgloss.Style
	cli       lipgloss.Style
	status    lipgloss.Style
	footer    lipgloss.Style
	completion lipgloss.Style
}

func buildStyles(m *Model) Styles {
	return Styles{
		header: lipgloss.NewStyle().
			Background(m.currentTheme.HeaderBg).
			Foreground(m.currentTheme.HeaderFg).
			Padding(0, 1),
		colsWrap: lipgloss.NewStyle(),
		colBox: lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(m.currentTheme.PaneBorderInactive),
		colBoxAct: lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(m.currentTheme.PaneBorderActive),
		cli: lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(m.currentTheme.PaneBorderActive),
		status: lipgloss.NewStyle().
			Border(lipgloss.NormalBorder()).
			BorderForeground(m.currentTheme.PaneBorderInactive),
		footer: lipgloss.NewStyle().
			Background(m.currentTheme.FooterBg).
			Foreground(m.currentTheme.FooterFg).
			Padding(0, 1),
		completion: lipgloss.NewStyle().Foreground(m.currentTheme.ComplFg),
	}
}

func (m *Model) renderFooter(s Styles, width int) string {
	var b strings.Builder
	b.WriteString(m.footerHelp)
	if len(m.suggestions) > 0 && m.activePane == replPane {
		b.WriteString(" | suggest: ")
		b.WriteString(s.completion.Render(strings.Join(m.suggestions, ", ")))
	}
	return s.footer.Width(width).Render(b.String())
}

func textBlink() func() tea.Msg { return textarea.Blink }

#MULTICAT_START
# dir: ./internal/tui
# file: model.go
# notes: modes, dynamic sizing state, list + markdown/source views
#MULTICAT_END
package tui

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/charmbracelet/bubbles/textarea"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/glamour"
)

type pane int

const (
	leftPane pane = iota
	rightPane
	replPane
)

type mode int

const (
	modeSelf mode = iota
	modeTasks
)

type Command struct {
	Name        string
	Description string
	Executor    func(m *Model, args []string) (string, error)
}

type Model struct {
	// panes
	leftVP       viewport.Model
	rightVP      viewport.Model
	repl         textarea.Model
	activePane   pane

	// data
	leftContent  []string // tree text
	rightContent string   // rendered doc/source

	// size
	width  int
	height int
	col1Ratio float64
	headerH   int
	cliH      int
	statusH   int
	footerH   int

	// behavior
	commands   map[string]Command
	apiPort    string
	program    *tea.Program

	// theming
	themes       map[string]Theme
	currentTheme Theme
	themeName    string

	// completer
	suggestions  []string
	footerHelp   string

	// domain
	curMode      mode
	projectRoot  string
	tubesDir     string
	selectedPath string
	lastCompile  string
}

func initialModel(port string) Model {
	ta := textarea.New()
	ta.Placeholder = "Type a /command and press Enter..."
	ta.Focus()
	ta.Prompt = "┃ "
	ta.CharLimit = 4096
	ta.SetHeight(1)
	ta.KeyMap.InsertNewline.SetEnabled(false)

	cwd, _ := os.Getwd()
	td := os.Getenv("TUBES_DIR")

	themes := map[string]Theme{"default": defaultTheme()}
	m := Model{
		repl:         ta,
		activePane:   replPane,
		themes:       themes,
		currentTheme: themes["default"],
		themeName:    "default",
		apiPort:      port,
		footerHelp:   "Tab: cycle | ←/→: resize cols | ↑/↓ (with Alt): resize bands | /mode | /open <path> | /run <action>",
		col1Ratio:    0.38,
		headerH:      1,
		cliH:         3,
		statusH:      1,
		footerH:      1,
		curMode:      modeSelf,
		projectRoot:  cwd,
		tubesDir:     td,
	}
	m.reloadLeft()
	m.renderRight(m.selectedPath)
	m.loadCommands()
	return m
}

func (m *Model) reloadLeft() {
	switch m.curMode {
	case modeSelf:
		tree := m.buildTree(m.projectRoot, func(path string, d os.DirEntry) bool {
			if d.IsDir() && strings.HasPrefix(d.Name(), ".") { return false }
			return true
		})
		m.leftContent = strings.Split(tree, "\n")
		if m.selectedPath == "" {
			m.selectedPath = filepath.Join(m.projectRoot, "project.tubes")
		}
	case modeTasks:
		root := m.tubesDir
		if root == "" {
			m.leftContent = []string{"TUBES_DIR not set."}
			return
		}
		tree := m.buildTree(root, func(path string, d os.DirEntry) bool { return true })
		m.leftContent = strings.Split(tree, "\n")
		if m.selectedPath == "" {
			m.selectedPath = root
		}
	}
	m.leftVP.SetContent(strings.Join(m.leftContent, "\n"))
}

func (m *Model) renderRight(path string) {
	if path == "" {
		m.rightContent = ""
		m.rightVP.SetContent("")
		return
	}
	data, err := os.ReadFile(path)
	if err != nil {
		m.rightContent = fmt.Sprintf("Error: %v", err)
		m.rightVP.SetContent(m.rightContent)
		return
	}
	ext := strings.ToLower(filepath.Ext(path))
	switch ext {
	case ".md", ".markdown", ".tubes":
		r, _ := glamour.NewTermRenderer(glamour.WithAutoStyle())
		out, _ := r.Render(string(data))
		m.rightContent = out
	default:
		// naive "color" by wrapping code block markers for readability
		m.rightContent = string(data)
	}
	m.rightVP.SetContent(m.rightContent)
}

func (m *Model) adjustColRatio(delta float64) {
	m.col1Ratio += delta
	if m.col1Ratio < 0.15 { m.col1Ratio = 0.15 }
	if m.col1Ratio > 0.85 { m.col1Ratio = 0.85 }
}

func (m *Model) adjustBand(which string, delta int) {
	switch which {
	case "header":
		m.headerH += delta
		if m.headerH < 1 { m.headerH = 1 }
	case "cli":
		m.cliH += delta
		if m.cliH < 1 { m.cliH = 1 }
	case "status":
		m.statusH += delta
		if m.statusH < 1 { m.statusH = 1 }
	case "footer":
		m.footerH += delta
		if m.footerH < 1 { m.footerH = 1 }
	}
}

func (m *Model) buildTree(root string, allow func(string, os.DirEntry) bool) string {
	var b strings.Builder
	prefix := ""
	var walk func(string, string)
	walk = func(dir, pref string) {
		ents, _ := os.ReadDir(dir)
		for i, e := range ents {
			if !allow(filepath.Join(dir, e.Name()), e) { continue }
			last := i == len(ents)-1
			conn := "├─ "
			nextPref := pref + "│  "
			if last {
				conn = "└─ "
				nextPref = pref + "   "
			}
			b.WriteString(pref + conn + e.Name())
			// mark project.tubes
			if e.Name() == "project.tubes" {
				b.WriteString("  *")
			}
			b.WriteString("\n")
			if e.IsDir() {
				walk(filepath.Join(dir, e.Name()), nextPref)
			}
		}
	}
	b.WriteString(filepath.Base(root) + "/\n")
	walk(root, prefix)
	return b.String()
}

#MULTICAT_START
# dir: ./internal/tui
# file: commands.go
# notes: mode switch, resize, open, and run actions
#MULTICAT_END
package tui

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func (m *Model) loadCommands() {
	m.commands = map[string]Command{
		"/help": {
			Name: "/help", Description: "Show commands.",
			Executor: func(mm *Model, _ []string) (string, error) {
				return strings.TrimSpace(`
/help
/mode [self|tasks]
/open <relative-or-absolute-path>
/resize col [+|-]<pct> | band <header|cli|status|footer> [+|-]<n>
/run <llm-ask|llm-apply|compile|test|llm-commit|llm-reset> [args]
/clear
`), nil
			},
		},
		"/mode": {
			Name: "/mode [self|tasks]", Description: "Switch working mode.",
			Executor: func(mm *Model, args []string) (string, error) {
				if len(args) != 1 {
					return "", errors.New("usage: /mode [self|tasks]")
				}
				switch args[0] {
				case "self":
					mm.curMode = modeSelf
				case "tasks":
					mm.curMode = modeTasks
				default:
					return "", fmt.Errorf("unknown mode: %s", args[0])
				}
				mm.selectedPath = ""
				mm.reloadLeft()
				return fmt.Sprintf("Mode set to %s", args[0]), nil
			},
		},
		"/open": {
			Name: "/open <path>", Description: "Open path in right column.",
			Executor: func(mm *Model, args []string) (string, error) {
				if len(args) < 1 {
					return "", errors.New("usage: /open <path>")
				}
				p := strings.Join(args, " ")
				if !filepath.IsAbs(p) {
					if mm.curMode == modeSelf {
						p = filepath.Join(mm.projectRoot, p)
					} else {
						if mm.tubesDir == "" {
							return "", errors.New("TUBES_DIR not set")
						}
						p = filepath.Join(mm.tubesDir, p)
					}
				}
				info, err := os.Stat(p)
				if err != nil {
					return "", err
				}
				if info.IsDir() {
					mm.selectedPath = p
					// refresh left to show new subtree root context line (optional)
					return "Opened directory (no right view)", nil
				}
				mm.selectedPath = p
				mm.renderRight(p)
				return fmt.Sprintf("Opened %s", p), nil
			},
		},
		"/resize": {
			Name: "/resize ...", Description: "Resize columns or bands.",
			Executor: func(mm *Model, args []string) (string, error) {
				if len(args) < 2 {
					return "", errors.New("usage: /resize col [+|-]pct  |  /resize band <header|cli|status|footer> [+|-]n")
				}
				switch args[0] {
				case "col":
					arg := args[1]
					sign := 1.0
					if strings.HasPrefix(arg, "-") {
						sign = -1.0
						arg = strings.TrimPrefix(arg, "-")
					} else if strings.HasPrefix(arg, "+") {
						arg = strings.TrimPrefix(arg, "+")
					}
					var pct float64
					fmt.Sscanf(arg, "%f", &pct)
					mm.adjustColRatio(sign * (pct / 100.0))
					return fmt.Sprintf("col1 ratio=%.2f", mm.col1Ratio), nil
				case "band":
					if len(args) < 3 {
						return "", errors.New("usage: /resize band <header|cli|status|footer> [+|-]n")
					}
					which := args[1]
					arg := args[2]
					sign := 1
					if strings.HasPrefix(arg, "-") {
						sign = -1
						arg = strings.TrimPrefix(arg, "-")
					} else if strings.HasPrefix(arg, "+") {
						arg = strings.TrimPrefix(arg, "+")
					}
					var n int
					fmt.Sscanf(arg, "%d", &n)
					mm.adjustBand(which, sign*n)
					return fmt.Sprintf("%s height=%d", which, bandValue(mm, which)), nil
				default:
					return "", errors.New("unknown /resize target")
				}
			},
		},
		"/run": {
			Name: "/run <action>", Description: "Run flow-type action (go).",
			Executor: func(mm *Model, args []string) (string, error) {
				if len(args) < 1 {
					return "", errors.New("usage: /run <llm-ask|llm-apply|compile|test|llm-commit|llm-reset> [args]")
				}
				action := args[0]
				switch action {
				case "compile":
					res := mm.compileFromProject()
					mm.lastCompile = res
					return "compile: " + res, nil
				case "test":
					return "test: " + mm.lastCompile, nil
				case "llm-ask":
					// stub: accept prompt + path to MULTICAT
					return "llm-ask: queued", nil
				case "llm-apply":
					// stub: would multisplit from llm output
					return "llm-apply: applied", nil
				case "llm-commit":
					return "llm-commit: done", nil
				case "llm-reset":
					return "llm-reset: done", nil
				default:
					return "", fmt.Errorf("unknown action: %s", action)
				}
			},
		},
		"/clear": {
			Name: "/clear", Description: "Clear left log (tree reload).",
			Executor: func(mm *Model, _ []string) (string, error) {
				mm.reloadLeft()
				return "cleared", nil
			},
		},
	}
}

func bandValue(m *Model, which string) int {
	switch which {
	case "header":
		return m.headerH
	case "cli":
		return m.cliH
	case "status":
		return m.statusH
	case "footer":
		return m.footerH
	}
	return 0
}

func (m *Model) updateSuggestions() {
	input := m.repl.Value()
	m.suggestions = []string{}
	if !strings.HasPrefix(input, "/") || strings.Contains(input, " ") {
		return
	}
	for name := range m.commands {
		if strings.HasPrefix(name, input) {
			m.suggestions = append(m.suggestions, name)
		}
	}
}

func (m *Model) applySuggestion() {
	if len(m.suggestions) > 0 {
		m.repl.SetValue(m.suggestions[0] + " ")
		m.repl.SetCursor(len(m.repl.Value()))
		m.updateSuggestions()
	}
}

func (m *Model) compileFromProject() string {
	cfg := filepath.Join(m.projectRoot, "project.tubes")
	data, err := os.ReadFile(cfg)
	if err != nil {
		return "project.tubes not found"
	}
	// very light parse: look for "compile:" line
	lines := strings.Split(string(data), "\n")
	for _, ln := range lines {
		ln = strings.TrimSpace(ln)
		if strings.HasPrefix(ln, "compile:") {
			cmd := strings.TrimSpace(strings.TrimPrefix(ln, "compile:"))
			return "would run: " + cmd
		}
	}
	return "no compile directive"
}

#MULTICAT_START
# dir: ./internal/tui
# file: view.go
# notes: render: header | cols | cli | status | footer; dynamic sizes
#MULTICAT_END
package tui

import (
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

func (m *Model) Init() tea.Cmd {
	return tea.Batch(textBlink())
}

func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.resizeLayout()

	case tea.KeyMsg:
		// REPL typing
		if m.activePane == replPane && msg.Type != tea.KeyEnter && msg.Type != tea.KeyTab {
			m.repl, cmd = m.repl.Update(msg)
			m.updateSuggestions()
			cmds = append(cmds, cmd)
		}
		switch msg.String() {
		case "ctrl+c", "esc":
			return m, tea.Quit
		case "tab":
			if m.activePane == replPane {
				m.applySuggestion()
			} else {
				m.cyclePane()
			}
		case "enter":
			if m.activePane == replPane {
				m.handleInput()
			}
		case "left":
			m.adjustColRatio(-0.02)
		case "right":
			m.adjustColRatio(+0.02)
		case "alt+up":
			m.adjustBand("status", +1)
		case "alt+down":
			m.adjustBand("status", -1)
		}
		// pass scroll keys to active left/right
		if m.activePane != replPane {
			switch m.activePane {
			case leftPane:
				m.leftVP, cmd = m.leftVP.Update(msg)
				cmds = append(cmds, cmd)
			case rightPane:
				m.rightVP, cmd = m.rightVP.Update(msg)
				cmds = append(cmds, cmd)
			}
		}
	}
	return m, tea.Batch(cmds...)
}

func (m *Model) View() string {
	if m.width == 0 {
		return "Initializing..."
	}
	s := buildStyles(m)
	l := m.computeLayout()

	// header
	title := "Tubes — mode: self"
	if m.curMode == modeTasks { title = "Tubes — mode: tasks" }
	header := s.header.Width(m.width).Render(title)

	// columns
	leftStyle := s.colBox
	rightStyle := s.colBox
	if m.activePane == leftPane {
		leftStyle = s.colBoxAct
	}
	if m.activePane == rightPane {
		rightStyle = s.colBoxAct
	}

	left := leftStyle.
		Width(l.LeftW - 2).
		Height(l.ColsH).
		Render(strings.Join(m.leftContent, "\n"))

	right := rightStyle.
		Width(l.RightW - 2).
		Height(l.ColsH).
		Render(m.rightVP.View())

	cols := lipgloss.JoinHorizontal(lipgloss.Top, left, right)

	// cli
	cli := s.cli.Width(m.width - 2).Height(m.cliH).Render(m.repl.View())

	// status
	statusText := "Ready"
	if m.lastCompile != "" {
		statusText = "Last: " + m.lastCompile
	}
	status := s.status.Width(m.width - 2).Height(m.statusH).Render(statusText)

	// footer
	footer := m.renderFooter(s, m.width)

	return lipgloss.JoinVertical(lipgloss.Left,
		header,
		cols,
		cli,
		status,
		footer,
	)
}

func (m *Model) resizeLayout() {
	l := m.computeLayout()
	m.leftVP.Width = l.LeftW - 2
	m.leftVP.Height = l.ColsH
	m.leftVP.SetContent(strings.Join(m.leftContent, "\n"))

	m.rightVP.Width = l.RightW - 2
	m.rightVP.Height = l.ColsH
	m.rightVP.SetContent(m.rightContent)

	m.repl.SetWidth(m.width - 2)
}

func (m *Model) cyclePane() {
	m.activePane = (m.activePane + 1) % 3
	if m.activePane == replPane {
		m.repl.Focus()
	} else {
		m.repl.Blur()
	}
}

#MULTICAT_START
# dir: ./
# file: project.tubes
# notes: minimal config for compile/test; parsed by /run compile
#MULTICAT_END
# Tubes project configuration (minimal)
name: tubes
language: go

# compile command used by /run compile
compile: go build -o tubes ./cmd/tubes

# test command (not executed; /run test returns last compile status)
test: go test ./...

#MULTICAT_START
# dir: ./
# file: README.md
# notes: usage cheatsheet
#MULTICAT_END
# Tubes TUI

Layout: `header` | `col1|col2` | `cli` | `status` | `footer`

## Commands
- `/mode self`  — project tree (left), source view (right)
- `/mode tasks` — `$TUBES_DIR/<tube-task-types>` (left), module view (right)
- `/open <path>` — open file in right column (relative to mode root)
- `/resize col +10` — increase left column width by 10%
- `/resize band status +1` — increase status height by 1 row
- `/run compile|test|llm-ask|llm-apply|llm-commit|llm-reset`
- `/help`

Environment: set `TUBES_DIR` to the tasks root when using `tasks` mode.

Build:
