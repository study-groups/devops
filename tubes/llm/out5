#MULTICAT_START
# dir: ./
# file: STATUS.md
# notes: Add tubes_diff_* and tubes_git_* bash functions and semantics doc
#MULTICAT_END
# Status

- Scripts: `tubes.sh` now includes `tubes_diff_*` and `tubes_git_*`
- Diff: guided creation, review, save, and apply of patch files
- Git: task-centric branch workflow, structured commit/reset helpers
- Semantics: prefer **task** over **flow** (see `SEMANTICS.md`)

#MULTICAT_START
# dir: ./
# file: tubes.sh
# notes: Bash functions with common prefixes "tubes_", "tubes_diff_", "tubes_git_"
#MULTICAT_END
#!/usr/bin/env bash
# Tubes helper functions
# shellcheck disable=SC2120

set -euo pipefail

#-------------------------
# General build/run/clean
#-------------------------

tubes_build() {
    echo "[tubes] go mod tidy"
    go mod tidy
    echo "[tubes] build ./cmd/tubes -> ./tubes"
    go build -o tubes ./cmd/tubes
}

tubes_run() {
    if [[ ! -x ./tubes ]]; then
        echo "[tubes] binary missing; building..."
        tubes_build
    fi
    echo "[tubes] run ./tubes $*"
    ./tubes "$@"
}

tubes_clean() {
    echo "[tubes] remove ./tubes"
    rm -f ./tubes
}

#-------------------------
# Diff helpers (patch IO)
#-------------------------
# Conventions:
# - Patches saved under ./patches/YYYYmmdd-HHMMSS.patch
# - Default pathspec: working tree changes (no args)
# - Uses `git diff` (unstaged) and `git diff --cached` (staged) where indicated

_tubes__ensure_git() {
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 || {
        echo "[tubes] error: not a git repository"; return 1; }
}

_tubes__patch_dir() { mkdir -p patches; printf "%s\n" "patches"; }
_tubes__timestamp() { date +"%Y%m%d-%H%M%S"; }

tubes_diff_help() {
    cat <<'EOF'
[tubes_diff_*] commands

  tubes_diff_show [--cached] [<pathspec>...]
      Show a colorized diff for given paths (or entire tree if omitted).
  tubes_diff_gen  [--cached] [<pathspec>...]
      Create a patch file under ./patches/. Prints patch path.
  tubes_diff_apply <patch-file>
      Apply the given patch with index (stages resulting changes).
  tubes_diff_walk
      Guided flow: choose scope -> preview -> save -> apply.

Examples:
  tubes_diff_show
  tubes_diff_gen --cached src/
  tubes_diff_apply patches/20250101-101500.patch
  tubes_diff_walk
EOF
}

tubes_diff_show() {
    _tubes__ensure_git || return 1
    local cached=0
    if [[ "${1-}" == "--cached" ]]; then cached=1; shift; fi
    if (( cached )); then
        git diff --cached --patch --color "$@"
    else
        git diff --patch --color "$@"
    fi
}

tubes_diff_gen() {
    _tubes__ensure_git || return 1
    local cached=0
    if [[ "${1-}" == "--cached" ]]; then cached=1; shift; fi
    local dir=$(_tubes__patch_dir)
    local out="${dir}/$(_tubes__timestamp).patch"
    if (( cached )); then
        git diff --cached --patch "$@" >"$out"
    else
        git diff --patch "$@" >"$out"
    fi
    if [[ ! -s "$out" ]]; then
        rm -f "$out"
        echo "[tubes] no diff to save"; return 2
    fi
    echo "$out"
}

tubes_diff_apply() {
    _tubes__ensure_git || return 1
    local patch=${1-}
    if [[ -z "$patch" || ! -f "$patch" ]]; then
        echo "[tubes] usage: tubes_diff_apply <patch-file>"; return 2; fi
    git apply --index --apply "$patch"
    echo "[tubes] applied (and staged): $patch"
}

tubes_diff_walk() {
    _tubes__ensure_git || return 1
    echo "[tubes] Diff walk-through"
    echo "Select scope:"
    echo "  1) working tree (unstaged)"
    echo "  2) staged (--cached)"
    read -r -p "[1/2]: " choice
    local mode=""; [[ "${choice:-1}" == "2" ]] && mode="--cached"

    read -r -p "Optional pathspec (enter for all): " spec
    echo "[tubes] previewing diff ..."
    if [[ -n "$spec" ]]; then
        tubes_diff_show $mode $spec | ${PAGER:-less -R}
    else
        tubes_diff_show $mode | ${PAGER:-less -R}
    fi

    read -r -p "Save patch? [y/N]: " save
    if [[ "${save,,}" != "y" ]]; then
        echo "[tubes] aborted"; return 0; fi

    local patch
    if [[ -n "$spec" ]]; then
        patch=$(tubes_diff_gen $mode $spec)
    else
        patch=$(tubes_diff_gen $mode)
    fi
    echo "[tubes] saved: $patch"

    read -r -p "Apply patch now (stages changes)? [y/N]: " apply
    if [[ "${apply,,}" == "y" ]]; then
        tubes_diff_apply "$patch"
    else
        echo "[tubes] skipping apply"
    fi
}

#-------------------------
# Git helpers (task-first)
#-------------------------
# Conventions:
# - Branch naming: tubes/task/<task-slug>
# - Commit message template includes task and optional flow context
# - 'llm-commit' => structured commit from staged changes
# - 'llm-reset'  => branch reset helper
# - Use tasks over flows; flows are execution graphs attached to a task.

tubes_git_help() {
    cat <<'EOF'
[tubes_git_*] commands

  tubes_git_start <task-slug> [base-branch=main]
      Create/switch to branch: tubes/task/<task-slug>.
  tubes_git_sync [remote=origin] [base-branch=main]
      Update base and rebase current task branch on latest base.
  tubes_git_commit [-m msg] [--flow <name>] [--no-signoff]
      Commit staged changes with Tubes message template.
  tubes_git_reset [--soft|--hard] [target=HEAD~1]
      Reset current branch (default: soft to HEAD~1).
  tubes_git_open
      Echo paths relevant to current mode (self/tasks).

Examples:
  tubes_git_start tokenize-pipeline
  tubes_diff_walk && tubes_git_commit -m "token filters"
  tubes_git_sync
  tubes_git_reset --soft
EOF
}

_tubes__current_task() {
    local b; b=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)
    [[ "$b" =~ ^tubes/task/ ]] && printf "%s\n" "${b#tubes/task/}" || printf "%s\n" ""
}

_tubes__slugify() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g; s/^-+|-+$//g'
}

tubes_git_start() {
    _tubes__ensure_git || return 1
    local task=${1-}; local base=${2-main}
    if [[ -z "$task" ]]; then echo "[tubes] usage: tubes_git_start <task-slug> [base-branch]"; return 2; fi
    local slug; slug=$(_tubes__slugify "$task")
    git fetch --all --prune
    git checkout "$base"
    git pull --ff-only || true
    local branch="tubes/task/${slug}"
    if git rev-parse --verify "$branch" >/dev/null 2>&1; then
        git checkout "$branch"
    else
        git checkout -b "$branch" "$base"
    fi
    echo "[tubes] on branch: $branch"
}

tubes_git_sync() {
    _tubes__ensure_git || return 1
    local remote=${1-origin}; local base=${2-main}
    local task; task=$(_tubes__current_task)
    if [[ -z "$task" ]]; then echo "[tubes] not on a tubes/task/* branch"; return 2; fi
    git fetch "$remote"
    git checkout "$base"
    git pull --ff-only
    git checkout "tubes/task/$task"
    git rebase "$base"
    echo "[tubes] rebased tubes/task/$task onto $base"
}

tubes_git_commit() {
    _tubes__ensure_git || return 1
    local msg=""; local flow=""
    local signoff="--signoff"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -m) shift; msg=${1-};;
            --flow) shift; flow=${1-};;
            --no-signoff) signoff="";;
            *) echo "[tubes] unknown arg: $1"; return 2;;
        esac
        shift || true
    done
    local task; task=$(_tubes__current_task)
    if [[ -z "$task" ]]; then echo "[tubes] not on a tubes/task/* branch"; return 2; fi
    if ! git diff --cached --quiet; then :; else
        echo "[tubes] nothing staged; use 'git add' or tubes_diff_apply"; return 2; fi

    local prefix="tubes(task:${task}"
    if [[ -n "$flow" ]]; then prefix="${prefix}/flow:${flow}"; fi
    prefix="${prefix})"
    local subject=${msg:-"checkpoint"}
    git commit ${signoff} -m "${prefix}: ${subject}"
}

tubes_git_reset() {
    _tubes__ensure_git || return 1
    local mode="--soft"; local target="HEAD~1"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --soft|--hard) mode="$1";;
            *) target="$1";;
        esac; shift || true
    done
    echo "[tubes] git reset ${mode} ${target}"
    git reset ${mode} "${target}"
}

tubes_git_open() {
    # Print roots relevant to model semantics (self/tasks). Does not read app state.
    local root_self; root_self=$(pwd)
    local root_tasks=${TUBES_DIR:-}
    echo "self:  ${root_self}"
    echo "tasks: ${root_tasks:-<unset>}"
}

# Default help if sourced interactively
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "Source this file:  source ./tubes.sh"
    echo "Help: tubes_diff_help ; tubes_git_help"
fi

#MULTICAT_START
# dir: ./
# file: SEMANTICS.md
# notes: Define task vs flow with Tubes-preferred semantics
#MULTICAT_END
# Tubes Semantics: Task vs Flow

## Task (preferred)
- Unit of work with a concrete objective and scope.
- Durable identity (branch: `tubes/task/<slug>`).
- Owns configuration and artifacts under `$TUBES_DIR/<task-type>/<task>/`.
- Commands are expressed **for a task** (`/run compile`, `llm-apply`, `llm-commit`).

## Flow
- Execution graph describing how steps run (e.g., for Go: `llm-ask`, `llm-apply`, `compile`, `test`, `llm-commit`, `llm-reset`).
- Attached to a **task**; a task may host one or more flows.
- Non-durable identity; flows evolve within the task lifecycle.

## Policy
- Prefer **task** first: name work, branch on task, commit to task.
- Bind flows to the active task; flows annotate commits as `flow:<name>` when needed.
