#MULTICAT_START
# dir: /Users/mricos/src/mricos/demos/tubes
# file: STATUS
# notes: Updated to fix undefined symbols and missing fields/methods in tui. Added message types, stubbed FZF info, implemented handleInput, added httpServer field, and minimal /api command to avoid nil access in server handler.
#MULTICAT_END
{
  "files": [
    "/Users/mricos/src/mricos/demos/tubes/STATUS",
    "/Users/mricos/src/mricos/demos/tubes/tubes.files",
    "/Users/mricos/src/mricos/demos/tubes/internal/tui/messages.go",
    "/Users/mricos/src/mricos/demos/tubes/internal/tui/repl.go",
    "/Users/mricos/src/mricos/demos/tubes/internal/tui/fzf.go",
    "/Users/mricos/src/mricos/demos/tubes/internal/tui/model.go",
    "/Users/mricos/src/mricos/demos/tubes/internal/tui/view.go",
    "/Users/mricos/src/mricos/demos/tubes/internal/tui/commands.go"
  ]
}
#MULTICAT_START
# dir: /Users/mricos/src/mricos/demos/tubes
# file: tubes.files
# notes: Files to review/apply via mc -r
#MULTICAT_END
internal/tui/messages.go
internal/tui/repl.go
internal/tui/fzf.go
internal/tui/model.go
internal/tui/view.go
internal/tui/commands.go
#MULTICAT_START
# dir: /Users/mricos/src/mricos/demos/tubes/internal/tui
# file: messages.go
# notes: Defines Bubble Tea message types referenced in server.go
#MULTICAT_END
package tui

// serverLogMsg is emitted by the HTTP server to append log lines to the left view.
type serverLogMsg struct {
	content string
}

// mainLogMsg is emitted by the HTTP server to surface short notices in the main UI.
type mainLogMsg struct {
	content string
}
#MULTICAT_START
# dir: /Users/mricos/src/mricos/demos/tubes/internal/tui
# file: fzf.go
# notes: Stub providing getFZFInfo referenced by server.go
#MULTICAT_END
package tui

// getFZFInfo returns a short diagnostic string for the /fzf/api endpoint.
// Replace with real integration as needed.
func getFZFInfo(_ *Model, _ []string) (string, error) {
	return "fzf: no integration configured", nil
}
#MULTICAT_START
# dir: /Users/mricos/src/mricos/demos/tubes/internal/tui
# file: repl.go
# notes: Implements Model.handleInput referenced by view.go
#MULTICAT_END
package tui

import (
	"strings"
)

// handleInput parses the REPL line and executes commands of the form `/cmd args...`.
// Non-command input is forwarded as a mainLogMsg.
func (m *Model) handleInput() {
	line := strings.TrimSpace(m.repl.Value())
	if line == "" {
		return
	}
	// Clear input and suggestions.
	m.repl.SetValue("")
	m.updateSuggestions()

	// Commands start with "/"
	if !strings.HasPrefix(line, "/") {
		if m.program != nil {
			m.program.Send(mainLogMsg{content: line})
		}
		return
	}

	fields := strings.Fields(line)
	name := fields[0]
	args := []string{}
	if len(fields) > 1 {
		args = fields[1:]
	}
	if cmd, ok := m.commands[name]; ok && cmd.Executor != nil {
		out, err := cmd.Executor(m, args)
		if err != nil {
			m.leftContent = append(m.leftContent, "ERR: "+err.Error())
		} else if out != "" {
			m.leftContent = append(m.leftContent, out)
		}
		m.leftVP.SetContent(strings.Join(m.leftContent, "\n"))
		return
	}
	m.leftContent = append(m.leftContent, "unknown command: "+name)
	m.leftVP.SetContent(strings.Join(m.leftContent, "\n"))
}
#MULTICAT_START
# dir: /Users/mricos/src/mricos/demos/tubes/internal/tui
# file: model.go
# notes: Add httpServer field; keep rest intact
#MULTICAT_END
package tui

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/charmbracelet/bubbles/textarea"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/glamour"
)

type pane int

const (
	leftPane pane = iota
	rightPane
	replPane
)

type mode int

const (
	modeSelf mode = iota
	modeTasks
)

type Command struct {
	Name        string
	Description string
	Executor    func(m *Model, args []string) (string, error)
}

type Model struct {
	// panes
	leftVP     viewport.Model
	rightVP    viewport.Model
	repl       textarea.Model
	activePane pane

	// data
	leftContent  []string // tree text
	rightContent string   // rendered doc/source

	// size
	width    int
	height   int
	col1Ratio float64
	headerH   int
	cliH      int
	statusH   int
	footerH   int

	// behavior
	commands map[string]Command
	apiPort  string
	program  *tea.Program

	// HTTP API server
	httpServer *http.Server

	// theming
	themes       map[string]Theme
	currentTheme Theme
	themeName    string

	// completer
	suggestions []string
	footerHelp  string

	// domain
	curMode      mode
	projectRoot  string
	tubesDir     string
	selectedPath string
	lastCompile  string
}

func initialModel(port string) Model {
	ta := textarea.New()
	ta.Placeholder = "Type a /command and press Enter..."
	ta.Focus()
	ta.Prompt = "┃ "
	ta.CharLimit = 4096
	ta.SetHeight(1)
	ta.KeyMap.InsertNewline.SetEnabled(false)

	cwd, _ := os.Getwd()
	td := os.Getenv("TUBES_DIR")

	themes := map[string]Theme{"default": defaultTheme()}
	m := Model{
		repl:         ta,
		activePane:   replPane,
		themes:       themes,
		currentTheme: themes["default"],
		themeName:    "default",
		apiPort:      port,
		footerHelp:   "Tab: cycle | ←/→: resize cols | ↑/↓ (with Alt): resize bands | /mode | /open <path> | /run <action>",
		col1Ratio:    0.38,
		headerH:      1,
		cliH:         3,
		statusH:      1,
		footerH:      1,
		curMode:      modeSelf,
		projectRoot:  cwd,
		tubesDir:     td,
	}
	m.reloadLeft()
	m.renderRight(m.selectedPath)
	m.loadCommands()
	return m
}

func (m *Model) reloadLeft() {
	switch m.curMode {
	case modeSelf:
		tree := m.buildTree(m.projectRoot, func(path string, d os.DirEntry) bool {
			if d.IsDir() && strings.HasPrefix(d.Name(), ".") {
				return false
			}
			return true
		})
		m.leftContent = strings.Split(tree, "\n")
		if m.selectedPath == "" {
			m.selectedPath = filepath.Join(m.projectRoot, "project.tubes")
		}
	case modeTasks:
		root := m.tubesDir
		if root == "" {
			m.leftContent = []string{"TUBES_DIR not set."}
			return
		}
		tree := m.buildTree(root, func(path string, d os.DirEntry) bool { return true })
		m.leftContent = strings.Split(tree, "\n")
		if m.selectedPath == "" {
			m.selectedPath = root
		}
	}
	m.leftVP.SetContent(strings.Join(m.leftContent, "\n"))
}

func (m *Model) renderRight(path string) {
	if path == "" {
		m.rightContent = ""
		m.rightVP.SetContent("")
		return
	}
	data, err := os.ReadFile(path)
	if err != nil {
		m.rightContent = fmt.Sprintf("Error: %v", err)
		m.rightVP.SetContent(m.rightContent)
		return
	}
	ext := strings.ToLower(filepath.Ext(path))
	switch ext {
	case ".md", ".markdown", ".tubes":
		r, _ := glamour.NewTermRenderer(glamour.WithAutoStyle())
		out, _ := r.Render(string(data))
		m.rightContent = out
	default:
		m.rightContent = string(data)
	}
	m.rightVP.SetContent(m.rightContent)
}

func (m *Model) adjustColRatio(delta float64) {
	m.col1Ratio += delta
	if m.col1Ratio < 0.15 {
		m.col1Ratio = 0.15
	}
	if m.col1Ratio > 0.85 {
		m.col1Ratio = 0.85
	}
}

func (m *Model) adjustBand(which string, delta int) {
	switch which {
	case "header":
		m.headerH += delta
		if m.headerH < 1 {
			m.headerH = 1
		}
	case "cli":
		m.cliH += delta
		if m.cliH < 1 {
			m.cliH = 1
		}
	case "status":
		m.statusH += delta
		if m.statusH < 1 {
			m.statusH = 1
		}
	case "footer":
		m.footerH += delta
		if m.footerH < 1 {
			m.footerH = 1
		}
	}
}

func (m *Model) buildTree(root string, allow func(string, os.DirEntry) bool) string {
	var b strings.Builder
	prefix := ""
	var walk func(string, string)
	walk = func(dir, pref string) {
		ents, _ := os.ReadDir(dir)
		for i, e := range ents {
			if !allow(filepath.Join(dir, e.Name()), e) {
				continue
			}
			last := i == len(ents)-1
			conn := "├─ "
			nextPref := pref + "│  "
			if last {
				conn = "└─ "
				nextPref = pref + "   "
			}
			b.WriteString(pref + conn + e.Name())
			if e.Name() == "project.tubes" {
				b.WriteString("  *")
			}
			b.WriteString("\n")
			if e.IsDir() {
				walk(filepath.Join(dir, e.Name()), nextPref)
			}
		}
	}
	b.WriteString(filepath.Base(root) + "/\n")
	walk(root, prefix)
	return b.String()
}
#MULTICAT_START
# dir: /Users/mricos/src/mricos/demos/tubes/internal/tui
# file: view.go
# notes: Handle serverLogMsg and mainLogMsg; keep previous logic
#MULTICAT_END
package tui

import (
	"strings"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

func (m *Model) Init() tea.Cmd {
	return tea.Batch(textBlink())
}

func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.width = msg.Width
		m.height = msg.Height
		m.resizeLayout()

	case tea.KeyMsg:
		// REPL typing
		if m.activePane == replPane && msg.Type != tea.KeyEnter && msg.Type != tea.KeyTab {
			m.repl, cmd = m.repl.Update(msg)
			m.updateSuggestions()
			cmds = append(cmds, cmd)
		}
		switch msg.String() {
		case "ctrl+c", "esc":
			return m, tea.Quit
		case "tab":
			if m.activePane == replPane {
				m.applySuggestion()
			} else {
				m.cyclePane()
			}
		case "enter":
			if m.activePane == replPane {
				m.handleInput()
			}
		case "left":
			m.adjustColRatio(-0.02)
		case "right":
			m.adjustColRatio(+0.02)
		case "alt+up":
			m.adjustBand("status", +1)
		case "alt+down":
			m.adjustBand("status", -1)
		}
		// pass scroll keys to active left/right
		if m.activePane != replPane {
			switch m.activePane {
			case leftPane:
				m.leftVP, cmd = m.leftVP.Update(msg)
				cmds = append(cmds, cmd)
			case rightPane:
				m.rightVP, cmd = m.rightVP.Update(msg)
				cmds = append(cmds, cmd)
			}
		}

	case serverLogMsg:
		m.leftContent = append(m.leftContent, msg.content)
		m.leftVP.SetContent(strings.Join(m.leftContent, "\n"))

	case mainLogMsg:
		// Prepend for visibility.
		m.rightContent = msg.content + "\n" + m.rightContent
		m.rightVP.SetContent(m.rightContent)
	}

	return m, tea.Batch(cmds...)
}

func (m *Model) View() string {
	if m.width == 0 {
		return "Initializing..."
	}
	s := buildStyles(m)
	l := m.computeLayout()

	// header
	title := "Tubes — mode: self"
	if m.curMode == modeTasks {
		title = "Tubes — mode: tasks"
	}
	header := s.header.Width(m.width).Render(title)

	// columns
	leftStyle := s.colBox
	rightStyle := s.colBox
	if m.activePane == leftPane {
		leftStyle = s.colBoxAct
	}
	if m.activePane == rightPane {
		rightStyle = s.colBoxAct
	}

	left := leftStyle.
		Width(l.LeftW - 2).
		Height(l.ColsH).
		Render(strings.Join(m.leftContent, "\n"))

	right := rightStyle.
		Width(l.RightW - 2).
		Height(l.ColsH).
		Render(m.rightVP.View())

	cols := lipgloss.JoinHorizontal(lipgloss.Top, left, right)

	// cli
	cli := s.cli.Width(m.width - 2).Height(m.cliH).Render(m.repl.View())

	// status
	statusText := "Ready"
	if m.lastCompile != "" {
		statusText = "Last: " + m.lastCompile
	}
	status := s.status.Width(m.width - 2).Height(m.statusH).Render(statusText)

	// footer
	footer := m.renderFooter(s, m.width)

	return lipgloss.JoinVertical(lipgloss.Left,
		header,
		cols,
		cli,
		status,
		footer,
	)
}

func (m *Model) resizeLayout() {
	l := m.computeLayout()
	m.leftVP.Width = l.LeftW - 2
	m.leftVP.Height = l.ColsH
	m.leftVP.SetContent(strings.Join(m.leftContent, "\n"))

	m.rightVP.Width = l.RightW - 2
	m.rightVP.Height = l.ColsH
	m.rightVP.SetContent(m.rightContent)

	m.repl.SetWidth(m.width - 2)
}

func (m *Model) cyclePane() {
	m.activePane = (m.activePane + 1) % 3
	if m.activePane == replPane {
		m.repl.Focus()
	} else {
		m.repl.Blur()
	}
}
#MULTICAT_START
# dir: /Users/mricos/src/mricos/demos/tubes/internal/tui
# file: commands.go
# notes: Adds minimal "/api" to satisfy server.go's reference
#MULTICAT_END
package tui

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func (m *Model) loadCommands() {
	m.commands = map[string]Command{
		"/help": {
			Name: "/help", Description: "Show commands.",
			Executor: func(mm *Model, _ []string) (string, error) {
				return strings.TrimSpace(`
/help
/mode [self|tasks]
/open <relative-or-absolute-path>
/resize col [+|-]<pct> | band <header|cli|status|footer> [+|-]<n>
/run <llm-ask|llm-apply|compile|test|llm-commit|llm-reset> [args]
/clear
/api
`), nil
			},
		},
		"/mode": {
			Name: "/mode [self|tasks]", Description: "Switch working mode.",
			Executor: func(mm *Model, args []string) (string, error) {
				if len(args) != 1 {
					return "", errors.New("usage: /mode [self|tasks]")
				}
				switch args[0] {
				case "self":
					mm.curMode = modeSelf
				case "tasks":
					mm.curMode = modeTasks
				default:
					return "", fmt.Errorf("unknown mode: %s", args[0])
				}
				mm.selectedPath = ""
				mm.reloadLeft()
				return fmt.Sprintf("Mode set to %s", args[0]), nil
			},
		},
		"/open": {
			Name: "/open <path>", Description: "Open path in right column.",
			Executor: func(mm *Model, args []string) (string, error) {
				if len(args) < 1 {
					return "", errors.New("usage: /open <path>")
				}
				p := strings.Join(args, " ")
				if !filepath.IsAbs(p) {
					if mm.curMode == modeSelf {
						p = filepath.Join(mm.projectRoot, p)
					} else {
						if mm.tubesDir == "" {
							return "", errors.New("TUBES_DIR not set")
						}
						p = filepath.Join(mm.tubesDir, p)
					}
				}
				info, err := os.Stat(p)
				if err != nil {
					return "", err
				}
				if info.IsDir() {
					mm.selectedPath = p
					return "Opened directory (no right view)", nil
				}
				mm.selectedPath = p
				mm.renderRight(p)
				return fmt.Sprintf("Opened %s", p), nil
			},
		},
		"/resize": {
			Name: "/resize ...", Description: "Resize columns or bands.",
			Executor: func(mm *Model, args []string) (string, error) {
				if len(args) < 2 {
					return "", errors.New("usage: /resize col [+|-]pct  |  /resize band <header|cli|status|footer> [+|-]n")
				}
				switch args[0] {
				case "col":
					arg := args[1]
					sign := 1.0
					if strings.HasPrefix(arg, "-") {
						sign = -1.0
						arg = strings.TrimPrefix(arg, "-")
					} else if strings.HasPrefix(arg, "+") {
						arg = strings.TrimPrefix(arg, "+")
					}
					var pct float64
					fmt.Sscanf(arg, "%f", &pct)
					mm.adjustColRatio(sign * (pct / 100.0))
					return fmt.Sprintf("col1 ratio=%.2f", mm.col1Ratio), nil
				case "band":
					if len(args) < 3 {
						return "", errors.New("usage: /resize band <header|cli|status|footer> [+|-]n")
					}
					which := args[1]
					arg := args[2]
					sign := 1
					if strings.HasPrefix(arg, "-") {
						sign = -1
						arg = strings.TrimPrefix(arg, "-")
					} else if strings.HasPrefix(arg, "+") {
						arg = strings.TrimPrefix(arg, "+")
					}
					var n int
					fmt.Sscanf(arg, "%d", &n)
					mm.adjustBand(which, sign*n)
					return fmt.Sprintf("%s height=%d", which, bandValue(mm, which)), nil
				default:
					return "", errors.New("unknown /resize target")
				}
			},
		},
		"/run": {
			Name: "/run <action>", Description: "Run flow-type action (go).",
			Executor: func(mm *Model, args []string) (string, error) {
				if len(args) < 1 {
					return "", errors.New("usage: /run <llm-ask|llm-apply|compile|test|llm-commit|llm-reset> [args]")
				}
				action := args[0]
				switch action {
				case "compile":
					res := mm.compileFromProject()
					mm.lastCompile = res
					return "compile: " + res, nil
				case "test":
					return "test: " + mm.lastCompile, nil
				case "llm-ask":
					return "llm-ask: queued", nil
				case "llm-apply":
					return "llm-apply: applied", nil
				case "llm-commit":
					return "llm-commit: done", nil
				case "llm-reset":
					return "llm-reset: done", nil
				default:
					return "", fmt.Errorf("unknown action: %s", action)
				}
			},
		},
		"/clear": {
			Name: "/clear", Description: "Clear left log (tree reload).",
			Executor: func(mm *Model, _ []string) (string, error) {
				mm.reloadLeft()
				return "cleared", nil
			},
		},
		"/api": {
			Name: "/api", Description: "List HTTP API endpoints.",
			Executor: func(_ *Model, _ []string) (string, error) {
				return "/api/list, /fzf/api, POST /log", nil
			},
		},
	}
}

func bandValue(m *Model, which string) int {
	switch which {
	case "header":
		return m.headerH
	case "cli":
		return m.cliH
	case "status":
		return m.statusH
	case "footer":
		return m.footerH
	}
	return 0
}

func (m *Model) updateSuggestions() {
	input := m.repl.Value()
	m.suggestions = []string{}
	if !strings.HasPrefix(input, "/") || strings.Contains(input, " ") {
		return
	}
	for name := range m.commands {
		if strings.HasPrefix(name, input) {
			m.suggestions = append(m.suggestions, name)
		}
	}
}

func (m *Model) applySuggestion() {
	if len(m.suggestions) > 0 {
		m.repl.SetValue(m.suggestions[0] + " ")
		m.repl.SetCursor(len(m.repl.Value()))
		m.updateSuggestions()
	}
}

func (m *Model) compileFromProject() string {
	cfg := filepath.Join(m.projectRoot, "project.tubes")
	data, err := os.ReadFile(cfg)
	if err != nil {
		return "project.tubes not found"
	}
	// very light parse: look for "compile:" line
	lines := strings.Split(string(data), "\n")
	for _, ln := range lines {
		ln = strings.TrimSpace(ln)
		if strings.HasPrefix(ln, "compile:") {
			cmd := strings.TrimSpace(strings.TrimPrefix(ln, "compile:"))
			return "would run: " + cmd
		}
	}
	return "no compile directive"
}
