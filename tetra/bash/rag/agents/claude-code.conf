# Claude Code Agent Profile - Optimized for Anthropic's Claude models
# Tailored for Claude's structured, thoughtful approach to code generation

AGENT_NAME="claude-code"
AGENT_DESCRIPTION="Optimized for Claude Code and Anthropic models"

# Claude responds well to structured, example-rich instructions
AGENT_INSTRUCTION_TEMPLATE="You are generating code files in MULTICAT format for a software project.

## Output Format Requirements

✅ CORRECT format:
#MULTICAT_START
# dir: ./src/components
# file: Button.jsx
# note: Reusable button component with variants
#MULTICAT_END
import React from 'react';
// ... rest of file content

❌ NEVER do this:
\`\`\`javascript
#MULTICAT_START
// ... (wrapped in code blocks)
\`\`\`

## Guidelines
- Use ONLY the raw MULTICAT format shown above
- Start each file with #MULTICAT_START header
- Include informative # note: descriptions
- Use relative paths starting with ./
- Write clean, well-structured code
- Consider error handling and edge cases
- Follow the existing project patterns

## Context
The following files contain the current codebase. Analyze the patterns, dependencies, and architecture before generating your response.

"

# Claude-optimized example with comprehensive structure
AGENT_EXAMPLE_TEMPLATE="#MULTICAT_START
# dir: ./src/hooks
# file: useDebounce.js
# note: Custom React hook for debouncing values
#MULTICAT_END
import { useState, useEffect } from 'react';

/**
 * Custom hook that debounces a value
 * @param {any} value - The value to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {any} The debounced value
 */
export const useDebounce = (value, delay) => {
    const [debouncedValue, setDebouncedValue] = useState(value);

    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);

        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);

    return debouncedValue;
};

#MULTICAT_START
# dir: ./src/components
# file: SearchInput.jsx
# note: Search input component with debounced onChange
#MULTICAT_END
import React, { useState, useCallback } from 'react';
import { useDebounce } from '../hooks/useDebounce';

const SearchInput = ({ onSearch, placeholder = 'Search...', delay = 300 }) => {
    const [inputValue, setInputValue] = useState('');
    const debouncedValue = useDebounce(inputValue, delay);

    const handleInputChange = useCallback((e) => {
        setInputValue(e.target.value);
    }, []);

    // Trigger search when debounced value changes
    React.useEffect(() => {
        if (onSearch && typeof onSearch === 'function') {
            onSearch(debouncedValue);
        }
    }, [debouncedValue, onSearch]);

    return (
        <div className=\"search-input-container\">
            <input
                type=\"text\"
                value={inputValue}
                onChange={handleInputChange}
                placeholder={placeholder}
                className=\"search-input\"
                aria-label=\"Search input\"
            />
        </div>
    );
};

export default SearchInput;

#MULTICAT_START
# dir: ./src/utils
# file: validation.js
# note: Input validation utilities with comprehensive error handling
#MULTICAT_END
/**
 * Validation utilities for form inputs and data
 */

export const ValidationError = class extends Error {
    constructor(message, field) {
        super(message);
        this.name = 'ValidationError';
        this.field = field;
    }
};

export const validators = {
    required: (value, fieldName) => {
        if (value == null || value === '' || (typeof value === 'string' && value.trim() === '')) {
            throw new ValidationError(\`\${fieldName} is required\`, fieldName);
        }
        return value;
    },

    email: (value, fieldName = 'Email') => {
        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;
        if (!emailRegex.test(value)) {
            throw new ValidationError(\`\${fieldName} must be a valid email address\`, fieldName);
        }
        return value;
    },

    minLength: (minLen) => (value, fieldName) => {
        if (typeof value === 'string' && value.length < minLen) {
            throw new ValidationError(\`\${fieldName} must be at least \${minLen} characters\`, fieldName);
        }
        return value;
    }
};

export const validateObject = (obj, schema) => {
    const errors = {};

    for (const [field, validatorFns] of Object.entries(schema)) {
        try {
            const value = obj[field];
            for (const validator of validatorFns) {
                validator(value, field);
            }
        } catch (error) {
            if (error instanceof ValidationError) {
                errors[field] = error.message;
            } else {
                throw error;
            }
        }
    }

    if (Object.keys(errors).length > 0) {
        const error = new Error('Validation failed');
        error.validationErrors = errors;
        throw error;
    }

    return obj;
};
"

# Claude-specific preferences
PREFER_CONCISE_OUTPUT="false"      # Claude can handle detailed explanations
INCLUDE_EXAMPLES="true"            # Claude benefits from examples
INCLUDE_CONTEXT_HINTS="true"       # Claude uses context well
MAX_SUGGESTED_FILES="25"           # Balanced context size
CONTEXT_WINDOW_SIZE="200000"       # Claude has large context windows
ENCOURAGE_DOCUMENTATION="true"     # Claude writes good documentation
CONSIDER_EDGE_CASES="true"         # Claude is good at comprehensive solutions

# Function to generate Claude-specific examples
generate_claude_code_example() {
    echo "$AGENT_EXAMPLE_TEMPLATE"
}