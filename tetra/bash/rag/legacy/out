#MULTICAT_START
# dir: .
# file: ecosystem.config.js
# notes: PM2 configuration file pointing to the correct entry point.
#MULTICAT_END
module.exports = {
  apps: [{
    name: 'tetra-console',
    script: './src/index.js',
    watch: ['./src'],
    ignore_watch: ['node_modules'],
    watch_options: {
      followSymlinks: false
    },
    env: {
      "NODE_ENV": "development",
    }
  }]
};

#MULTICAT_START
# dir: .
# file: package.json
# notes: Includes dependencies and helpful run scripts.
#MULTICAT_END
{
  "name": "tetra-console",
  "version": "1.0.0",
  "description": "Tetra Console for CI/CD",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "express": "^4.19.2",
    "node-pty": "^1.0.0",
    "socket.io": "^4.7.5"
  },
  "devDependencies": {
    "nodemon": "^3.1.4"
  }
}

#MULTICAT_START
# dir: ./public
# file: index.html
# notes: The main user interface for the console.
#MULTICAT_END
<!doctype html>
<html>
<head>
    <title>Tetra Console</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
    <link rel="stylesheet" href="style.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
</head>
<body>
    <div id="tetra-container">
        <header>
            <h1>Tetra Console</h1>
            <div id="status-indicator">
                Current State: <span id="current-state">Idle</span>
            </div>
        </header>

        <div id="context-panel">
            <h2>Context</h2>
            <div class="context-grid">
                <label for="remote-user">Remote User:</label>
                <input type="text" id="remote-user" value="dev-user">

                <label for="remote-host">Remote Host:</label>
                <input type="text" id="remote-host" value="dev.server.com">
                
                <label for="repo-dir">Repo:</label>
                <input type="text" id="repo-dir" value="my-app-repo">

                <label for="project-dir">Project:</label>
                <input type="text" id="project-dir" value="frontend">

                <label for="merge-branch">Branch:</label>
                <input type="text" id="merge-branch" value="feature/new-ui">
            </div>
        </div>
        
        <div id="action-panel">
            <h2>Actions</h2>
            <div class="action-buttons">
                <button id="btn-merge">1. Merge</button>
                <button id="btn-prep" disabled>2. Prep</button>
                <button id="btn-build" disabled>3. Build</button>
                <button id="btn-restart" disabled>4. Restart</button>
                <button id="btn-stop" disabled>5. Stop</button>
            </div>
        </div>

        <main id="terminal-container">
            <div id="terminal"></div>
        </main>
    </div>

    <script src="script.js"></script>
</body>
</html>

#MULTICAT_START
# dir: ./public
# file: style.css
# notes: Stylesheet for the console UI.
#MULTICAT_END
body {
    font-family: 'Menlo', 'Consolas', 'monospace';
    background-color: #1e1e1e;
    color: #d4d4d4;
    margin: 0;
    padding: 20px;
    font-size: 14px;
}

#tetra-container {
    display: grid;
    grid-template-areas:
        "header header"
        "context actions"
        "terminal terminal";
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto 1fr;
    gap: 20px;
    max-width: 1200px;
    margin: auto;
}

header {
    grid-area: header;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #444;
    padding-bottom: 10px;
}

h1, h2 {
    color: #4ec9b0; /* Teal */
    margin-top: 0;
}

#status-indicator {
    background-color: #333;
    padding: 5px 15px;
    border-radius: 5px;
    font-size: 1em;
}

#status-indicator span {
    font-weight: bold;
    color: #c586c0; /* Purple */
}

#context-panel, #action-panel {
    background-color: #252526;
    padding: 20px;
    border-radius: 8px;
    border: 1px solid #333;
}

#context-panel { grid-area: context; }
#action-panel { grid-area: actions; }

.context-grid {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 10px;
    align-items: center;
}

label {
    font-weight: bold;
    color: #9cdcfe; /* Light Blue */
}

input {
    background-color: #3c3c3c;
    color: #d4d4d4;
    border: 1px solid #555;
    padding: 8px;
    border-radius: 4px;
    width: 95%;
}

.action-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}

button {
    background-color: #4ec9b0; /* Teal */
    color: #1e1e1e;
    font-weight: bold;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.2s;
    font-size: 1em;
}

button:hover {
    background-color: #5ddabf;
}

button:disabled {
    background-color: #444;
    color: #888;
    cursor: not-allowed;
}

#terminal-container {
    grid-area: terminal;
    background-color: #1e1e1e;
    padding: 10px;
    border: 1px solid #333;
    border-radius: 8px;
    height: 50vh; 
}

#MULTICAT_START
# dir: ./public
# file: script.js
# notes: Frontend JavaScript to handle UI and WebSocket communication.
#MULTICAT_END
document.addEventListener('DOMContentLoaded', function () {
    const term = new Terminal({
        cursorBlink: true,
        theme: {
            background: '#1e1e1e',
            foreground: '#d4d4d4',
        }
    });
    const fitAddon = new FitAddon.FitAddon();
    term.loadAddon(fitAddon);
    term.open(document.getElementById('terminal'));
    fitAddon.fit();
    
    const socket = io();

    const states = {
        IDLE: { next: 'MERGING', button: 'btn-merge' },
        MERGING: { next: 'READY_TO_BUILD', button: 'btn-prep' },
        READY_TO_BUILD: { next: 'BUILT', button: 'btn-build' },
        BUILT: { next: 'RUNNING', button: 'btn-restart' },
        RUNNING: { next: 'STOPPED', button: 'btn-stop' },
        STOPPED: { next: 'IDLE', button: 'btn-merge' },
    };
    let currentState = 'IDLE';

    const stateDisplay = document.getElementById('current-state');
    const buttons = {
        merge: document.getElementById('btn-merge'),
        prep: document.getElementById('btn-prep'),
        build: document.getElementById('btn-build'),
        restart: document.getElementById('btn-restart'),
        stop: document.getElementById('btn-stop'),
    };

    function updateUI() {
        stateDisplay.textContent = currentState.replace('_', '-');
        Object.values(buttons).forEach(btn => btn.disabled = true);
        
        if (currentState === 'RUNNING') {
            buttons.stop.disabled = false;
        } else if (currentState === 'STOPPED') {
            buttons.merge.disabled = false;
        } else if (states[currentState]) {
            const nextAction = states[currentState].button;
            const buttonElement = document.getElementById(nextAction);
            if(buttonElement) buttonElement.disabled = false;
        }
    }

    function getContext() {
        return {
            REMOTE_USER: document.getElementById('remote-user').value,
            REMOTE_HOST: document.getElementById('remote-host').value,
            REPO_DIR: document.getElementById('repo-dir').value,
            PROJECT_DIR: document.getElementById('project-dir').value,
            MERGE_BRANCH: document.getElementById('merge-branch').value
        };
    }

    function runAction(action, scriptName) {
        if (states[currentState]?.button !== `btn-${action}`) {
            term.writeln(`\r\n\x1b[31mError: Cannot run '${action}' from state '${currentState}'.\x1b[0m`);
            return;
        }

        const context = getContext();
        
        const envExports = Object.entries(context)
            .map(([key, value]) => `export ${key}='${value}';`)
            .join(' ');
        
        const command = `${envExports} ./scripts/${scriptName}\n`;
        
        currentState = states[currentState].next;
        updateUI();
        
        socket.emit('input', command);
    }

    socket.on('connect', () => {
        term.writeln('\r\n\x1b[32mâœ… WebSocket Connection Established\x1b[0m');
        term.writeln('Welcome to Tetra Console!');
        updateUI();
    });
    
    socket.on('output', (data) => {
        term.write(data);
    });
    
    term.onData((data) => {
        socket.emit('input', data);
    });
    
    window.addEventListener('resize', () => fitAddon.fit());

    buttons.merge.addEventListener('click', () => runAction('merge', 'merge.sh'));
    buttons.prep.addEventListener('click', () => runAction('prep', 'prep.sh'));
    buttons.build.addEventListener('click', () => runAction('build', 'build.sh'));
    buttons.restart.addEventListener('click', () => runAction('restart', 'restart.sh'));
    buttons.stop.addEventListener('click', () => runAction('stop', 'stop.sh'));
});

#MULTICAT_START
# dir: ./src
# file: app.js
# notes: Sets up the Express app and static file serving.
#MULTICAT_END
const express = require('express');
const path = require('path');

const app = express();

// Serve static files (HTML, CSS, client-side JS) from the 'public' directory
const publicDirectoryPath = path.join(__dirname, '../public');
app.use(express.static(publicDirectoryPath));

// A simple root route to ensure the app is alive
app.get('/health', (req, res) => {
  res.status(200).send({ status: 'UP' });
});

module.exports = app;

#MULTICAT_START
# dir: ./src
# file: index.js
# notes: Main server entry point. Handles server startup and graceful shutdown.
#MULTICAT_END
const http = require('http');
const { Server } = require('socket.io');
const app = require('./app');
const terminalManager = require('./services/terminal'); // Import the manager

const PORT = process.env.PORT || 4444;
const server = http.createServer(app);
const io = new Server(server);

// Start the terminal and connect it to the WebSocket server.
terminalManager.start();
terminalManager.connect(io);

server.listen(PORT, () => {
  console.log(`ðŸš€ Tetra Console server running on port ${PORT}`);
});

// --- Clean, Async Graceful Shutdown ---

async function gracefulShutdown(signal) {
  console.log(`\n[Server] Received ${signal}, shutting down gracefully...`);
  
  // 1. Wait for the terminal manager to confirm its process is dead.
  await terminalManager.shutdown();

  // 2. Close the HTTP server.
  server.close(() => {
    console.log('[Server] HTTP server closed.');
    // 3. Exit the main process.
    process.exit(0);
  });
}

process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

process.on('uncaughtException', (err, origin) => {
  console.error(`[Server] Uncaught Exception at: ${origin}`, err);
  gracefulShutdown('uncaughtException');
});

#MULTICAT_START
# dir: ./src/services
# file: terminal.js
# notes: The robust, self-contained terminal manager.
#MULTICAT_END
const pty = require('node-pty');
const os = require('os');

const shell = os.platform() === 'win32' ? 'powershell.exe' : 'bash';

// This is our self-contained Terminal Manager singleton.
const terminalManager = {
  ptyProcess: null,

  // Creates the one and only PTY process.
  start() {
    if (this.ptyProcess) {
      return; // Already started
    }
    console.log('[PTY Manager] Starting terminal process...');
    this.ptyProcess = pty.spawn(shell, [], {
      name: 'xterm-color',
      cols: 80,
      rows: 30,
      cwd: process.env.HOME,
      env: process.env,
    });

    this.ptyProcess.write('PS1="\\$ "\r\n');
    this.ptyProcess.write('clear\r\n');
  },

  // Connects the PTY to the Socket.IO server.
  connect(io) {
    if (!this.ptyProcess) {
      this.start();
    }

    // Broadcast data from the PTY to all clients.
    this.ptyProcess.onData((data) => {
      io.emit('output', data);
    });

    // Handle new client connections.
    io.on('connection', (socket) => {
      console.log(`[Socket.IO] Client connected: ${socket.id}`);
      socket.emit('output', '\r\n--- ðŸŸ¢ Client connected to shared terminal ðŸŸ¢ ---\r\n');
      this.ptyProcess.write('\r\n');

      // Handle input from a client.
      socket.on('input', (data) => {
        if (this.ptyProcess) {
          this.ptyProcess.write(data);
        }
      });
    });
  },

  // A robust, Promise-based shutdown method.
  shutdown() {
    return new Promise((resolve, reject) => {
      if (!this.ptyProcess) {
        return resolve(); // Nothing to do.
      }
      console.log('[PTY Manager] Shutdown initiated. Killing PTY process.');
      this.ptyProcess.onExit(() => {
        console.log('[PTY Manager] PTY process confirmed dead.');
        this.ptyProcess = null;
        resolve();
      });
      this.ptyProcess.kill();
    });
  },
};

module.exports = terminalManager;
