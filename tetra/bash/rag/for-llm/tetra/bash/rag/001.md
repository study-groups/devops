# MULTICAT Toolchain Specification

## Project Intention

The goal of this project is to create a minimal, auditable workflow for managing file content and diffs using a plain-text archival format called **MULTICAT**. The format allows structured storage, transformation, and replay of file content blocks through a common header system, enabling:

* Full and partial (diff) content inclusion
* Robust integration with LLM workflows
* Controlled, logged expansion of diffs using local disk
* A composable CLI pipeline

Each tool in the suite provides a distinct role in the content lifecycle. Together, they enforce **structured versioning**, **reproducibility**, and **disk-aware patching** without external dependencies.

---

## Tools

| Script          | Role                                                       |
| --------------- | ---------------------------------------------------------- |
| `multicat.sh`   | Emits files into `MULTICAT` format (always recursive)      |
| `multisplit.sh` | Extracts blocks from `.mc` files into real files or stdout |
| `multdiff.sh`   | Expands `mode: diff` blocks using local disk context       |
| `mcinfo.sh`     | Lists and summarizes blocks from `.mc` files               |

---

## MULTICAT Block Format

```text
#MULTICAT_START
# dir: /path/to/file
# file: main.js
# mode: diff           (optional: 'diff' or 'full'; default: full)
# requires: true       (optional: set if disk context used)
# note: suspicious     (optional: set if disk file not declared)
#MULTICAT_END
<file content or unified diff here>
```

---

## CLI Workflow

### Step 1: Capture full file state

```bash
./multicat.sh ./src > 000-full.mc
```

### Step 2: Send to LLM and receive diff

LLM outputs patch-based update with `mode: diff`.

### Step 3: Expand diffs and resolve from disk

```bash
cat 001-patch.mc | ./multdiff.sh > 001-expanded.mc
```

### Step 4: Write to filesystem

```bash
./multisplit.sh -y 001-expanded.mc
```

### Step 5: Inspect

```bash
./mcinfo.sh 001-expanded.mc
```

---

## Latest Implementation (MULTICAT Encoded)

```text
#MULTICAT_START
# dir: ./tools
# file: multicat.sh
#MULTICAT_END
#!/usr/bin/env bash
# multicat.sh — Concatenates files into MULTICAT format
set -euo pipefail

include_files=()
exclude_patterns=()
recursive=1
dryrun=0

usage() {
  echo "Usage: $0 [-x exclude.txt] [file|dir ...]"
  echo "  -x <file>        Exclude patterns file"
  echo "  --dryrun         Show files that would be included"
  exit 1
}

array_to_regex() {
  local IFS="|"
  [[ $# -eq 0 ]] && echo '^$' || echo ".*($*)$"
}

load_excludes() {
  local path="$1"
  [[ -f "$path" ]] || return
  while IFS= read -r line; do
    [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue
    exclude_patterns+=("$line")
  done < "$path"
}

resolve_files() {
  local item="$1"
  local resolved
  if ! resolved=$(realpath "$item" 2>/dev/null); then
    echo "Warning: cannot resolve $item" >&2; return
  fi

  if [[ -f "$resolved" ]]; then
    [[ "$resolved" =~ $exclude_regex ]] || echo "$resolved"
  elif [[ -d "$resolved" ]]; then
    find "$resolved" -type f -print0 | while IFS= read -r -d '' f; do
      [[ "$f" =~ $exclude_regex ]] || realpath "$f"
    done
  fi
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -x) shift; load_excludes "$1" ;;
    --dryrun) dryrun=1 ;;
    -h|--help) usage ;;
    -*)
      echo "Unknown option: $1" >&2
      usage
      ;;
    *) include_files+=("$1") ;;
  esac
  shift
done

[[ ${#include_files[@]} -eq 0 ]] && usage

exclude_regex=$(array_to_regex "${exclude_patterns[@]}")

all_files=()
for item in "${include_files[@]}"; do
  while IFS= read -r f; do
    all_files+=("$f")
  done < <(resolve_files "$item")
done

if [[ $dryrun -eq 1 ]]; then
  printf "%s\n" "${all_files[@]}"
  exit 0
fi

for f in "${all_files[@]}"; do
  dir=$(dirname "$f")
  base=$(basename "$f")
  {
    echo "#MULTICAT_START"
    echo "# dir: $dir"
    echo "# file: $base"
    echo "# notes:"
    echo "#MULTICAT_END"
    cat "$f"
    echo
  }
done

#MULTICAT_START
# dir: ./tools
# file: multisplit.sh
#MULTICAT_END
#!/usr/bin/env bash
# multisplit.sh: Extract MULTICAT blocks from a file or stdin.

set -euo pipefail

CUTOFF_DIR="$(pwd)"
OUTPUT_ROOT="./"

safe_printf() {
  local fmt="$1"; shift
  [[ "$fmt" == -* ]] && fmt=" $fmt"
  printf "$fmt\n" "$@"
}

write_block() {
  local idx="$1" dir="$2" name="$3" body="$4" yolo="$5" print="$6"
  local rel="${dir#$CUTOFF_DIR}"
  rel="${rel#/}"
  local path="$OUTPUT_ROOT/$rel/$name"

  if [[ "$print" -eq 1 ]]; then
    safe_printf "------------------------------"
    safe_printf "file %d: %s" "$idx" "$name"
    safe_printf "location: %s" "$dir"
    safe_printf "------------------------------"
    safe_printf "%s" "$body"
    safe_printf "------------------------------"
    return
  fi

  mkdir -p "$(dirname "$path")"
  if [[ -f "$path" && "$yolo" -eq 0 ]]; then
    printf "File exists: %s\nOverwrite? [y/N]: " "$path"
    read -r ans </dev/tty || true
    ans=$(echo "$ans" | tr '[:upper:]' '[:lower:]')
    [[ "$ans" != "y" ]] && echo "Skipping $path" && return
  fi
  printf "%s" "$body" > "$path"
  echo "Wrote $path"
}

process_input() {
  local stream="$1" yolo="$2" print="$3"
  local idx=0 dir="" name="" content="" state="none"

  while IFS= read -r line || [[ -n "$line" ]]; do
    case "$state" in
      none)
        [[ "$line" == "#MULTICAT_START" ]] && state="header"
        ;;
      header)
        [[ "$line" == "#MULTICAT_END" ]] && state="content"
        [[ "$line" == "# dir: "* ]] && dir="${line#"# dir: "}"
        [[ "$line" == "# file: "* ]] && name="${line#"# file: "}"
        ;;
      content)
        if [[ "$line" == "#MULTICAT_START" ]]; then
          idx=$((idx+1))
          write_block "$idx" "$dir" "$name" "$content" "$yolo" "$print"
          dir="" name="" content=""
          state="header"
        else
          content+="$line"$'\n'
        fi
        ;;
    esac
  done <<< "$stream"

  [[ "$state" == "content" ]] && idx=$((idx+1)) && write_block "$idx" "$dir" "$name" "$content" "$yolo" "$print"
}

show_help() {
  cat <<EOF
multisplit: Extract MULTICAT-defined files.

Usage:
  $0 [OPTIONS] INPUT_FILE|-    (use '-' for stdin)

Options:
  -y          Overwrite files without prompting
  -Y          Overwrite files silently (no prompt)
  -p          Print to stdout (default)
  -h          Show this help message
EOF
}

main() {
  local prompt=0 force=0 print=1 input=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y) prompt=1; print=0 ;;
      -Y) force=1; print=0 ;;
      -p) print=1 ;;
      -h) show_help; exit 0 ;;
      -*)
        echo "Unknown option: $1" >&2; exit 1 ;;
      *) input="$1" ;;
    esac
    shift
  done

  [[ -z "$input" ]] && { echo "Missing input"; show_help; exit 1; }

  if [[ "$input" == "-" ]]; then
    process_input "$(cat)" "$prompt" "$force"
  elif [[ -f "$input" ]]; then
    process_input "$(cat "$input")" "$prompt" "$force"
  else
    echo "Invalid input: $input" >&2
    exit 1
  fi
}

main "$@"

#MULTICAT_START
# dir: ./tools
# file: multdiff.sh
#MULTICAT_END
#!/usr/bin/env bash
# multdiff.sh — Expand diff blocks using disk context

set -euo pipefail

expand_diff() {
  local dir="$1"
  local file="$2"
  local patch="$3"
  local path="$dir/$file"

  [[ ! -f "$path" ]] && { echo "__MISSING__"; return 1; }

  if ! expanded=$(patch --silent --merge "$path" <<< "$patch" 2>/dev/null); then
    echo "__FAILED__"; return 2
  fi

  echo "$expanded"
}

process_multicat() {
  local in_block=0 mode=full requires=no note=
  local dir= file= content=

  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" == "#MULTICAT_START" ]]; then
      in_block=1; mode="full"; requires="no"; note=""; dir=""; file=""; content=""
      continue
    elif [[ "$line" == "#MULTICAT_END" ]]; then
      if [[ "$mode" == "diff" ]]; then
        expanded=$(expand_diff "$dir" "$file" "$content") || status=$?
        if [[ "$expanded" == "__MISSING__" ]]; then
          requires="true"; note="suspicious"
        elif [[ "$expanded" == "__FAILED__" ]]; then
          echo "Patch failed for $dir/$file" >&2; exit 1
        else
          content="$expanded"; mode="full"
        fi
      fi
      echo "#MULTICAT_START"
      echo "# dir: $dir"
      echo "# file: $file"
      [[ "$mode" == "diff" ]] && echo "# mode: diff"
      [[ "$requires" == "true" ]] && echo "# requires: true"
      [[ -n "$note" ]] && echo "# note: $note"
      echo "#MULTICAT_END"
      printf "%s\n\n" "$content"
      in_block=0
      continue
    fi

    if [[ "$in_block" -eq 1 ]]; then
      case "$line" in
        "# dir: "*) dir="${line#"# dir: "}" ;;
        "# file: "*) file="${line#"# file: "}" ;;
        "# mode: "*) mode="${line#"# mode: "}" ;;
        *) content+="$line"$'\n' ;;
      esac
    fi
  done
}

process_multicat

#MULTICAT_START
# dir: ./tools
# file: mcinfo.sh
#MULTICAT_END
#!/bin/bash
# mcinfo.sh - Summary of a MULTICAT archive
set -euo pipefail

if [[ $# -eq 0 || "$1" == "-h" ]]; then
  echo "Usage: $0 <file.mc>"; exit 1
fi

file="$1"
[[ -f "$file" ]] || { echo "No such file: $file" >&2; exit 1; }

count=0 in_block=0 dir= file_name=

while IFS= read -r line; do
  case "$line" in
    "#MULTICAT_START") in_block=1; dir=; file_name= ;;
    "#MULTICAT_END") count=$((count+1)); echo "[$count] $dir/$file_name"; in_block=0 ;;
    "# dir: "*) [[ $in_block -eq 1 ]] && dir="${line#"# dir: "}" ;;
    "# file: "*) [[ $in_block -eq 1 ]] && file_name="${line#"# file: "}" ;;
  esac
done

echo "Total blocks: $count"
```
