#!/usr/bin/env bash
# bash/tree/shell_complete.sh - Shell Completion Generator
# Generates bash completions for CLI mode from tree structure

# Source dependencies
if [[ -z "$TETRA_SRC" ]]; then
    echo "Error: TETRA_SRC must be set" >&2
    return 1
fi

source "$TETRA_SRC/bash/tree/core.sh"
source "$TETRA_SRC/bash/tree/complete.sh"

# Generate bash completion function for a command
# Usage: tree_generate_shell_completion "command_name" "tree_namespace"
# Example: tree_generate_shell_completion "rag" "help.rag"
tree_generate_shell_completion() {
    local command_name="$1"
    local tree_namespace="$2"

    if [[ -z "$command_name" || -z "$tree_namespace" ]]; then
        echo "Error: tree_generate_shell_completion requires command and namespace" >&2
        return 1
    fi

    # Create completion function
    eval "
    _${command_name}_complete() {
        local cur prev words cword
        _init_completion || return

        local namespace='$tree_namespace'
        local path=\"\$namespace\"

        # Build path from command words
        local i
        for ((i=1; i<\$cword; i++)); do
            local word=\"\${words[\$i]}\"
            # Skip flags and options
            [[ \"\$word\" == -* ]] && continue
            # Skip if looks like a value (contains =)
            [[ \"\$word\" == *=* ]] && continue
            # Add to path
            [[ -n \"\$word\" ]] && path=\"\$path.\$word\"
        done

        # Get completions from tree
        local completions
        completions=\$(tree_complete \"\$path\" \"\$cur\" 2>/dev/null)

        # If no child completions, try dynamic/static values
        if [[ -z \"\$completions\" ]] && tree_exists \"\$path\" 2>/dev/null; then
            # Try dynamic completion
            local completion_fn
            completion_fn=\$(tree_get \"\$path\" \"completion_fn\" 2>/dev/null)
            if [[ -n \"\$completion_fn\" ]] && command -v \"\$completion_fn\" >/dev/null 2>&1; then
                completions=\$(\"\$completion_fn\" \"\$cur\" 2>/dev/null | tr '\\n' ' ')
            fi

            # Fall back to static values
            if [[ -z \"\$completions\" ]]; then
                completions=\$(tree_complete_values \"\$path\" 2>/dev/null)
            fi
        fi

        # Convert to array
        local comp_array=(\$completions)
        COMPREPLY=(\$(compgen -W \"\${comp_array[*]}\" -- \"\$cur\"))
    }

    complete -F _${command_name}_complete $command_name
    "
}

# Register shell completion for a module
# Usage: tree_register_shell_completion "module_name" ["namespace"]
# Example: tree_register_shell_completion "rag" "help.rag"
tree_register_shell_completion() {
    local module_name="$1"
    local namespace="${2:-help.$module_name}"

    if [[ -z "$module_name" ]]; then
        echo "Error: tree_register_shell_completion requires module_name" >&2
        return 1
    fi

    # Generate and register completion
    tree_generate_shell_completion "$module_name" "$namespace"
}

# Generate completion script that can be sourced
# Usage: tree_generate_completion_script "module_name" "namespace" > /path/to/completion.sh
# Example: tree_generate_completion_script "rag" "help.rag" > ~/.bash_completion.d/rag
tree_generate_completion_script() {
    local module_name="$1"
    local namespace="$2"

    if [[ -z "$module_name" || -z "$namespace" ]]; then
        echo "Error: tree_generate_completion_script requires module and namespace" >&2
        return 1
    fi

    cat <<EOF
#!/usr/bin/env bash
# Bash completion for $module_name
# Generated by tree_generate_completion_script

# Source tree system if not already loaded
if ! command -v tree_complete >/dev/null 2>&1; then
    if [[ -n "\$TETRA_SRC" ]]; then
        source "\$TETRA_SRC/bash/tree/core.sh" 2>/dev/null || true
        source "\$TETRA_SRC/bash/tree/complete.sh" 2>/dev/null || true
    fi
fi

# Completion function
_${module_name}_complete() {
    local cur prev words cword
    _init_completion 2>/dev/null || {
        # Fallback if bash-completion not available
        COMPREPLY=()
        cur="\${COMP_WORDS[COMP_CWORD]}"
        prev="\${COMP_WORDS[COMP_CWORD-1]}"
        words=("\${COMP_WORDS[@]}")
        cword=\$COMP_CWORD
    }

    local namespace="$namespace"
    local path="\$namespace"

    # Build path from command words
    local i
    for ((i=1; i<\$cword; i++)); do
        local word="\${words[\$i]}"
        # Skip flags and options
        [[ "\$word" == -* ]] && continue
        # Skip if looks like a value (contains =)
        [[ "\$word" == *=* ]] && continue
        # Add to path
        [[ -n "\$word" ]] && path="\$path.\$word"
    done

    # Get completions from tree if available
    if command -v tree_complete >/dev/null 2>&1; then
        local completions
        completions=\$(tree_complete "\$path" "\$cur" 2>/dev/null)

        # If no child completions, try dynamic/static values
        if [[ -z "\$completions" ]] && tree_exists "\$path" 2>/dev/null; then
            # Try dynamic completion
            local completion_fn
            completion_fn=\$(tree_get "\$path" "completion_fn" 2>/dev/null)
            if [[ -n "\$completion_fn" ]] && command -v "\$completion_fn" >/dev/null 2>&1; then
                completions=\$("\$completion_fn" "\$cur" 2>/dev/null | tr '\n' ' ')
            fi

            # Fall back to static values
            if [[ -z "\$completions" ]]; then
                completions=\$(tree_complete_values "\$path" 2>/dev/null)
            fi
        fi

        # Convert to array
        local comp_array=(\$completions)
        COMPREPLY=(\$(compgen -W "\${comp_array[*]}" -- "\$cur"))
    fi
}

complete -F _${module_name}_complete $module_name
EOF
}

# Install completions for all registered modules
# Usage: tree_install_all_completions [output_dir]
# Example: tree_install_all_completions ~/.bash_completion.d
tree_install_all_completions() {
    local output_dir="${1:-$HOME/.bash_completion.d}"

    if [[ ! -d "$output_dir" ]]; then
        mkdir -p "$output_dir" || {
            echo "Error: Cannot create completion directory: $output_dir" >&2
            return 1
        }
    fi

    # Check for module registry
    if ! declare -p REPL_MODULE_REGISTRY >/dev/null 2>&1; then
        echo "Warning: No modules registered in REPL_MODULE_REGISTRY" >&2
        return 1
    fi

    # Generate completion for each registered module
    for module in "${!REPL_MODULE_REGISTRY[@]}"; do
        # Skip namespace entries
        [[ "$module" == *:namespace ]] && continue

        local namespace="${REPL_MODULE_REGISTRY[${module}:namespace]:-help.$module}"
        local output_file="$output_dir/$module"

        echo "Generating completion for $module -> $output_file"
        tree_generate_completion_script "$module" "$namespace" > "$output_file"
        chmod +x "$output_file"
    done

    echo ""
    echo "Completions installed to: $output_dir"
    echo "To enable, add to your ~/.bashrc:"
    echo "  for f in $output_dir/*; do source \"\$f\"; done"
}

# Export functions
export -f tree_generate_shell_completion
export -f tree_register_shell_completion
export -f tree_generate_completion_script
export -f tree_install_all_completions
