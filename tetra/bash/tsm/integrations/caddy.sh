#!/usr/bin/env bash
# TSM Caddy Integration - reverse proxy management
# Load with: source $TSM_SRC/integrations/caddy.sh

TSM_CADDY_DIR="${TETRA_DIR}/caddy"
TSM_CADDYFILE="${TSM_CADDY_DIR}/Caddyfile"

# Generate Caddyfile from running TSM processes
tsm_caddy_generate() {
    local domain="${1:-localhost}"

    mkdir -p "$TSM_CADDY_DIR"

    echo "# Generated by TSM $(date)" > "$TSM_CADDYFILE"
    echo "" >> "$TSM_CADDYFILE"

    local count=0
    for dir in "$TSM_PROCESSES_DIR"/*/; do
        [[ -d "$dir" ]] || continue
        local name=$(basename "$dir")
        [[ "$name" == .* ]] && continue

        local meta="${dir}meta.json"
        [[ -f "$meta" ]] || continue

        local port=$(jq -r '.port // empty' "$meta" 2>/dev/null)
        local pid=$(jq -r '.pid // empty' "$meta" 2>/dev/null)

        # Skip if not running or no port
        tsm_is_pid_alive "$pid" || continue
        [[ -z "$port" || "$port" == "null" || "$port" == "0" ]] && continue

        # Add reverse proxy entry
        cat >> "$TSM_CADDYFILE" <<EOF
${name}.${domain} {
    reverse_proxy localhost:${port}
}

EOF
        ((count++))
    done

    echo "Generated Caddyfile with $count service(s)"
    echo "  File: $TSM_CADDYFILE"
}

# Show current Caddyfile
tsm_caddy_show() {
    if [[ -f "$TSM_CADDYFILE" ]]; then
        cat "$TSM_CADDYFILE"
    else
        echo "No Caddyfile found. Generate with: tsm caddy generate"
    fi
}

# Reload Caddy
tsm_caddy_reload() {
    if command -v caddy >/dev/null 2>&1; then
        caddy reload --config "$TSM_CADDYFILE" 2>/dev/null || {
            echo "Caddy not running. Start with: tsm caddy start"
            return 1
        }
        echo "Caddy reloaded"
    else
        echo "Caddy not installed"
        return 1
    fi
}

# Start Caddy
tsm_caddy_start() {
    if ! command -v caddy >/dev/null 2>&1; then
        echo "Caddy not installed. Install with: brew install caddy"
        return 1
    fi

    [[ -f "$TSM_CADDYFILE" ]] || tsm_caddy_generate

    caddy start --config "$TSM_CADDYFILE"
    echo "Caddy started"
}

# Stop Caddy
tsm_caddy_stop() {
    caddy stop 2>/dev/null && echo "Caddy stopped" || echo "Caddy not running"
}

# Caddy status
tsm_caddy_status() {
    if pgrep -x caddy >/dev/null 2>&1; then
        echo "Caddy: running (PID $(pgrep -x caddy))"
        [[ -f "$TSM_CADDYFILE" ]] && echo "Config: $TSM_CADDYFILE"
    else
        echo "Caddy: not running"
    fi
}

# Main caddy command
tsm_caddy() {
    local cmd="${1:-status}"
    shift 2>/dev/null || true

    case "$cmd" in
        generate|gen)  tsm_caddy_generate "$@" ;;
        show)          tsm_caddy_show ;;
        reload)        tsm_caddy_reload ;;
        start)         tsm_caddy_start ;;
        stop)          tsm_caddy_stop ;;
        status)        tsm_caddy_status ;;
        help|-h)
            cat <<'EOF'
TSM Caddy - reverse proxy management

Usage:
  tsm caddy              Show status
  tsm caddy generate [domain]  Generate Caddyfile from running processes
  tsm caddy show         Show current Caddyfile
  tsm caddy start        Start Caddy
  tsm caddy stop         Stop Caddy
  tsm caddy reload       Reload Caddy config

Examples:
  tsm caddy generate localhost
  tsm caddy generate myapp.local
  tsm caddy start
EOF
            ;;
        *)
            tsm_error "caddy: unknown command: $cmd"
            return 1
            ;;
    esac
}

# === AUTO-RELOAD HOOK ===

# Auto-reload hook - called after any process starts or stops
# Regenerates Caddyfile and reloads Caddy when TSM_CADDY_AUTORELOAD=true
_tsm_caddy_autoreload_hook() {
    local proc_name="$1"
    local port="$2"

    # Skip if autoreload disabled
    [[ "${TSM_CADDY_AUTORELOAD:-false}" == "true" ]] || return 0

    # Skip if this IS the caddy process (avoid infinite loop)
    [[ "$proc_name" == caddy* ]] && return 0

    # Skip if caddy not installed
    if ! command -v caddy >/dev/null 2>&1; then
        if [[ -z "${_TSM_CADDY_WARN_SHOWN:-}" ]]; then
            echo "tsm: caddy not installed, auto-reload disabled" >&2
            export _TSM_CADDY_WARN_SHOWN=1
        fi
        return 0
    fi

    # Skip if caddy not running (check via admin API or pgrep)
    if ! pgrep -x caddy >/dev/null 2>&1; then
        return 0
    fi

    # Regenerate Caddyfile
    tsm_caddy_generate "${TSM_CADDY_DOMAIN:-localhost}" >/dev/null 2>&1

    # Reload via admin API (graceful, no restart needed)
    if curl -s -X POST "http://localhost:2019/load" \
        -H "Content-Type: text/caddyfile" \
        --data-binary "@$TSM_CADDYFILE" >/dev/null 2>&1; then
        : # Success, silent
    else
        # Fallback: signal reload
        caddy reload --config "$TSM_CADDYFILE" >/dev/null 2>&1 || true
    fi
}

# Register hooks if hooks system is available
if declare -F tsm_hook_register &>/dev/null; then
    tsm_hook_register "post_start" "_tsm_caddy_autoreload_hook"
    tsm_hook_register "post_stop" "_tsm_caddy_autoreload_hook"
fi

