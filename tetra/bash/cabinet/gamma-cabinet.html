<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ANSI Cabinet</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #888;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }

    /* Unified header bar */
    #header {
      width: 100%;
      max-width: 640px;
      background: #111;
      border: 2px solid #333;
      padding: 6px 10px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #gamma-btn {
      font-family: 'Courier New', monospace;
      font-size: 11px;
      font-weight: bold;
      padding: 4px 8px;
      background: linear-gradient(180deg, #1a0a1a 0%, #0a0a1a 100%);
      color: #f0f;
      border: 2px solid #606;
      cursor: pointer;
      letter-spacing: 1px;
      text-decoration: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #gamma-btn:hover {
      background: linear-gradient(180deg, #2a1a2a 0%, #1a1a2a 100%);
      color: #f5f;
      border-color: #808;
    }
    #gamma-btn:active { background: #303; }
    #header .time-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #header .time-group .hw-label {
      font-size: 9px;
      color: #444;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    #header .time-group .hw-value {
      font-size: 12px;
      color: #0f0;
      font-family: 'Courier New', monospace;
    }
    #header .time-group .hw-value.warning { color: #f80; }
    #header .time-group .hw-value.critical { color: #f00; animation: blink 0.5s infinite; }
    #header .extend-btn {
      font-family: 'Courier New', monospace;
      font-size: 9px;
      padding: 2px 6px;
      background: #1a1a1a;
      color: #666;
      border: 1px solid #333;
      cursor: pointer;
    }
    #header .extend-btn:hover { background: #222; color: #0f0; border-color: #0a0; }
    #game-name {
      flex: 1;
      text-align: center;
      font-size: 14px;
      color: #0ff;
      letter-spacing: 3px;
      font-weight: bold;
      cursor: pointer;
    }
    #game-name:hover { color: #0f0; }
    #game-name.clickable { text-decoration: underline; text-decoration-style: dotted; }
    #reset-btn {
      width: 28px;
      height: 28px;
      background: #200;
      border: 2px solid #500;
      color: #800;
      font-weight: bold;
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #reset-btn:hover { background: #300; color: #f00; border-color: #700; }
    #reset-btn:active { background: #500; color: #fff; }

    /* Control panel */
    #control-panel {
      width: 100%;
      max-width: 640px;
      background: #0c0c0c;
      border: 2px solid #222;
      border-top: none;
      padding: 8px 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    #start-btn {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 8px 20px;
      background: #020;
      color: #0a0;
      border: 2px solid #0a0;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: bold;
    }
    #start-btn:hover { background: #030; color: #0f0; border-color: #0f0; }
    #start-btn:active { background: #050; }
    #start-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .hw-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .hw-label {
      font-size: 9px;
      color: #444;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .hw-value {
      font-size: 12px;
      color: #0f0;
      font-family: 'Courier New', monospace;
    }
    .hw-value.warning { color: #f80; }
    .hw-value.critical { color: #f00; animation: blink 0.5s infinite; }

    /* Hardware buttons */
    .hw-btn {
      font-family: 'Courier New', monospace;
      font-size: 10px;
      padding: 4px 8px;
      background: #1a1a1a;
      color: #666;
      border: 1px solid #333;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .hw-btn:hover { background: #222; color: #aaa; border-color: #444; }
    .hw-btn:active { background: #333; }
    .hw-btn.danger { border-color: #600; color: #a00; }
    .hw-btn.danger:hover { background: #300; color: #f00; border-color: #800; }

    /* Reset button - big red */
    #reset-btn {
      width: 50px;
      height: 24px;
      background: #200;
      border: 2px solid #500;
      border-radius: 3px;
      color: #800;
      font-weight: bold;
      font-size: 9px;
      cursor: pointer;
    }
    #reset-btn:hover { background: #300; color: #c00; border-color: #700; }
    #reset-btn:active { background: #500; color: #fff; }

    /* Game display */
    #game-display {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.15;
      white-space: pre;
      background: #000;
      padding: 8px;
      border: 2px solid #222;
      min-width: 500px;
      min-height: 300px;
      color: #0f0;
    }

    /* Status bar */
    #status-bar {
      width: 100%;
      max-width: 640px;
      background: #0c0c0c;
      border: 2px solid #222;
      border-top: none;
      padding: 6px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
    }
    #slot-display { color: #0ff; }
    #players-display { color: #050; }

    /* Join controls */
    #join-panel {
      width: 100%;
      max-width: 640px;
      background: #111;
      border: 2px solid #333;
      border-top: none;
      padding: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    #join-panel input, #join-panel select {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      padding: 6px 10px;
      background: #0a0a0a;
      color: #0f0;
      border: 1px solid #333;
    }
    #join-panel input:focus, #join-panel select:focus {
      outline: none;
      border-color: #0a0;
    }
    #join-target { width: 180px; }
    #nick-input { width: 80px; }
    #slot-select { width: 90px; }

    #join-btn {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 6px 16px;
      background: #020;
      color: #0a0;
      border: 1px solid #0a0;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    #join-btn:hover { background: #030; color: #0f0; }

    #takeover-btn {
      font-family: 'Courier New', monospace;
      font-size: 10px;
      padding: 4px 8px;
      background: #200;
      color: #a00;
      border: 1px solid #500;
      cursor: pointer;
      text-transform: uppercase;
    }
    #takeover-btn:hover { background: #300; color: #f00; }
    #takeover-btn:disabled { opacity: 0.3; cursor: not-allowed; }

    /* AI Panel */
    #ai-panel {
      width: 100%;
      max-width: 640px;
      background: #0c0c0c;
      border: 2px solid #222;
      border-top: none;
      padding: 8px 10px;
    }
    .ai-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .ai-player-btn {
      font-family: 'Courier New', monospace;
      font-size: 11px;
      padding: 6px 12px;
      background: #1a1a1a;
      color: #555;
      border: 2px solid #333;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 44px;
      transition: all 0.15s;
    }
    .ai-player-btn:hover { background: #222; }
    .ai-player-btn.off { color: #555; border-color: #333; background: #1a1a1a; }
    .ai-player-btn.internal { color: #f80; border-color: #a50; background: #221100; }
    .ai-player-btn.external { color: #0f0; border-color: #0a0; background: #002200; }
    .ai-player-btn.active { animation: ai-pulse 0.3s ease-out; }
    @keyframes ai-pulse { 0% { transform: scale(1.1); } 100% { transform: scale(1); } }

    /* Selected player params */
    #ai-params {
      margin-top: 8px;
      padding: 8px;
      background: #111;
      border: 1px solid #333;
      display: none;
    }
    #ai-params.visible { display: block; }
    #ai-params .param-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    #ai-params .param-label {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    #ai-params .param-mode {
      font-size: 11px;
      padding: 2px 6px;
    }
    #ai-params .param-mode.internal { color: #f80; }
    #ai-params .param-mode.external { color: #0f0; }
    #ai-params .param-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
    }
    #ai-params input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #000;
      border: 1px solid #333;
      cursor: pointer;
    }
    #ai-params input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: #222;
      border: 2px solid #555;
      cursor: pointer;
    }
    #ai-params input[type="range"]::-webkit-slider-thumb:hover {
      background: #333;
      border-color: #666;
    }
    #ai-params input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: #222;
      border: 2px solid #555;
      border-radius: 0;
      cursor: pointer;
    }
    #ai-params input[type="range"]::-moz-range-thumb:hover {
      background: #333;
      border-color: #666;
    }
    #ai-params .param-val { color: #0f0; font-size: 11px; width: 30px; text-align: right; }

    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

    /* Game Selection Modal */
    #game-modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    #game-modal.visible { display: flex; }
    #game-modal .modal-content {
      background: #111;
      border: 2px solid #0ff;
      padding: 20px;
      max-width: 400px;
      width: 90%;
    }
    #game-modal h2 {
      color: #0ff;
      font-size: 14px;
      letter-spacing: 2px;
      margin-bottom: 15px;
      text-align: center;
    }
    #game-modal .game-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 300px;
      overflow-y: auto;
    }
    #game-modal .game-option {
      background: #1a1a1a;
      border: 1px solid #333;
      padding: 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #game-modal .game-option:hover {
      border-color: #0ff;
      background: #1a2a2a;
    }
    #game-modal .game-option .game-title {
      color: #0ff;
      font-size: 13px;
      letter-spacing: 1px;
    }
    #game-modal .game-option .game-players {
      color: #666;
      font-size: 10px;
    }
    #game-modal .modal-close {
      margin-top: 15px;
      width: 100%;
      padding: 8px;
      background: #200;
      border: 1px solid #500;
      color: #a00;
      cursor: pointer;
      font-family: 'Courier New', monospace;
    }
    #game-modal .modal-close:hover { background: #300; color: #f00; }
  </style>
</head>
<body>
  <!-- Unified Header: GAMMA | TIME/+5M | GAME NAME | RESET -->
  <div id="header">
    <a id="gamma-btn" href="/" title="GAMMA Matchmaking">Γ</a>
    <div class="time-group">
      <span class="hw-label">TIME</span>
      <span class="hw-value" id="time-remaining">--:--</span>
      <button class="extend-btn" id="extend-btn">+5M</button>
    </div>
    <div id="game-name">---</div>
    <button id="reset-btn" title="Reset">R</button>
  </div>

  <!-- Game display (GAMMA boot screen rendered by JS) -->
  <pre id="game-display"></pre>

  <!-- Status bar -->
  <div id="status-bar">
    <span id="slot-display">OFFLINE</span>
    <span id="players-display"></span>
  </div>

  <!-- Control panel -->
  <div id="control-panel">
    <button id="start-btn">START</button>
    <span class="hw-label" id="control-status"></span>
  </div>

  <!-- Join panel -->
  <div id="join-panel">
    <input type="text" id="join-target" placeholder="Enter match code" autocomplete="off">
    <select id="slot-select">
      <option value="">AUTO</option>
      <option value="p1">P1</option>
      <option value="p2">P2</option>
      <option value="p3">P3</option>
      <option value="p4">P4</option>
    </select>
    <button id="join-btn">Connect</button>
    <button id="takeover-btn" disabled>Takeover</button>
    <input type="text" id="nick-input" placeholder="Nick">
  </div>

  <!-- AI Control Panel -->
  <div id="ai-panel">
    <div class="ai-row">
      <span class="hw-label">AI</span>
      <button id="ai-p1" class="ai-player-btn off" data-slot="p1">P1</button>
      <button id="ai-p2" class="ai-player-btn off" data-slot="p2">P2</button>
      <button id="ai-p3" class="ai-player-btn off" data-slot="p3">P3</button>
      <button id="ai-p4" class="ai-player-btn off" data-slot="p4">P4</button>
    </div>
    <div id="ai-params">
      <div class="param-header">
        <span class="param-label"><span id="param-slot">P1</span> AI Settings</span>
        <span id="param-mode" class="param-mode internal">Internal</span>
      </div>
      <div class="param-row">
        <span class="param-label">Skill</span>
        <input type="range" id="ai-skill" min="0" max="1" step="0.1" value="0.7">
        <span id="ai-skill-val" class="param-val">0.7</span>
      </div>
    </div>
  </div>

  <!-- Game Selection Modal -->
  <div id="game-modal">
    <div class="modal-content">
      <h2>SELECT GAME</h2>
      <div class="game-list" id="game-list">
        <!-- Games loaded dynamically -->
      </div>
      <button class="modal-close" onclick="closeGameModal()">CANCEL</button>
    </div>
  </div>

  <!-- External modules -->
  <script src="lib/config.js"></script>
  <script src="lib/stun.js"></script>

  <script>
    // ========================================
    // CABINET IDENTITY
    // ========================================
    const Cabinet = {
      init() {
        let data = localStorage.getItem('cabinet');
        if (data) {
          this.data = JSON.parse(data);
          this.data.visits++;
          this.data.lastSeen = Date.now();
        } else {
          this.data = {
            cid: 'cab_' + Math.random().toString(36).substr(2, 6),
            nick: '',
            visits: 1,
            firstSeen: Date.now(),
            lastSeen: Date.now(),
            slots: []
          };
        }
        this.save();
        return this;
      },
      save() { localStorage.setItem('cabinet', JSON.stringify(this.data)); },
      setNick(nick) { this.data.nick = nick.substring(0, 12); this.save(); },
      recordSlot(slot) {
        if (!this.data.slots.includes(slot)) {
          this.data.slots.push(slot);
          this.save();
        }
      }
    }.init();

    // ========================================
    // CONTROLDECK BRIDGE (BroadcastChannel)
    // ========================================
    const ControlDeckBridge = {
      enabled: false,
      stateChannel: null,
      gameChannel: null,
      inputChannel: null,
      gameInputChannel: null,

      init(gameType) {
        if (!window.BroadcastChannel) {
          console.log('[bridge] BroadcastChannel not supported');
          return this;
        }
        this.stateChannel = new BroadcastChannel('controldeck-game-state');
        this.inputChannel = new BroadcastChannel('controldeck-game-input');
        this.inputChannel.onmessage = (e) => this.handleAiOutput(e.data);
        if (gameType) this.setGame(gameType);
        this.enabled = true;
        console.log('[bridge] ControlDeck bridge enabled');
        return this;
      },

      setGame(gameType) {
        if (this.gameChannel) this.gameChannel.close();
        if (this.gameInputChannel) this.gameInputChannel.close();
        const stateName = `controldeck-${gameType.toLowerCase()}-state`;
        const inputName = `controldeck-${gameType.toLowerCase()}-input`;
        this.gameChannel = new BroadcastChannel(stateName);
        this.gameInputChannel = new BroadcastChannel(inputName);
        this.gameInputChannel.onmessage = (e) => this.handleAiOutput(e.data);
        console.log('[bridge] Game channels:', stateName, inputName);
      },

      broadcastState(state, gameName) {
        if (!this.enabled) return;
        const msg = { t: 'state', ts: Date.now(), game: gameName, state };
        if (this.stateChannel) this.stateChannel.postMessage(msg);
        if (this.gameChannel) this.gameChannel.postMessage(msg);
      },

      handleAiOutput(data) {
        if (!data || !data.axes) return;
        const slots = ['p1', 'p2', 'p3', 'p4'];
        for (let i = 0; i < Math.min(4, data.axes.length); i++) {
          const slot = slots[i];
          // Only forward external AI if player is set to 'external' mode
          if (LocalAI.players[slot].mode !== 'external') continue;
          const axis = data.axes[i];
          if (Math.abs(axis) > 0.01) {
            sendInput({
              t: 'input',
              src: 'ai',
              slot: slot,
              axis: axis,
              key: axis > 0 ? 'cw' : 'ccw',
              val: Math.abs(axis),
              pressed: true
            });
          }
        }
      }
    };

    // ========================================
    // LOCAL AI CONTROLLER (Quadrapong)
    // ========================================
    const LocalAI = {
      running: false,
      intervalId: null,
      state: {},
      TWO_PI: Math.PI * 2,
      MODES: ['off', 'internal', 'external'],
      selectedSlot: null,

      // Per-player settings
      players: {
        p1: { mode: 'off', skill: 0.7 },
        p2: { mode: 'off', skill: 0.7 },
        p3: { mode: 'off', skill: 0.7 },
        p4: { mode: 'off', skill: 0.7 }
      },

      init() {
        // Load saved settings
        this.load();
        // Restore button UI
        ['p1', 'p2', 'p3', 'p4'].forEach(slot => this.updateButtonUI(slot));
        // Start the tick loop (always running, checks modes internally)
        this.running = true;
        this.intervalId = setInterval(() => this.tick(), 33);
      },

      save() {
        localStorage.setItem('cabinet-ai', JSON.stringify(this.players));
      },

      load() {
        const saved = localStorage.getItem('cabinet-ai');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            for (const slot of ['p1', 'p2', 'p3', 'p4']) {
              if (data[slot]) {
                this.players[slot].mode = data[slot].mode || 'off';
                this.players[slot].skill = data[slot].skill ?? 0.7;
              }
            }
          } catch (e) {}
        }
      },

      cycleMode(slot) {
        const player = this.players[slot];
        const idx = this.MODES.indexOf(player.mode);
        player.mode = this.MODES[(idx + 1) % this.MODES.length];
        this.updateButtonUI(slot);
        this.selectPlayer(slot);
        this.save();
        return player.mode;
      },

      setSkill(slot, skill) {
        this.players[slot].skill = skill;
        this.save();
      },

      selectPlayer(slot) {
        this.selectedSlot = slot;
        const player = this.players[slot];
        const paramsEl = document.getElementById('ai-params');
        const slotEl = document.getElementById('param-slot');
        const modeEl = document.getElementById('param-mode');
        const skillEl = document.getElementById('ai-skill');
        const skillValEl = document.getElementById('ai-skill-val');

        if (player.mode === 'off') {
          paramsEl.classList.remove('visible');
        } else {
          paramsEl.classList.add('visible');
          slotEl.textContent = slot.toUpperCase();
          modeEl.textContent = player.mode.charAt(0).toUpperCase() + player.mode.slice(1);
          modeEl.className = 'param-mode ' + player.mode;
          skillEl.value = player.skill;
          skillValEl.textContent = player.skill.toFixed(1);
        }
      },

      updateButtonUI(slot) {
        const btn = document.getElementById(`ai-${slot}`);
        const player = this.players[slot];
        btn.classList.remove('off', 'internal', 'external');
        btn.classList.add(player.mode);
      },

      updateState(newState) {
        this.state = newState;
      },

      hasActiveAI() {
        return Object.values(this.players).some(p => p.mode !== 'off');
      },

      tick() {
        const state = this.state;
        if (!state.ball || !state.paddles || state.gameOver) return;

        const axes = [0, 0, 0, 0];
        const slots = ['p1', 'p2', 'p3', 'p4'];
        const HALF_PI = Math.PI / 2;

        const angleDiff = (a, b) => {
          let diff = a - b;
          while (diff > Math.PI) diff -= this.TWO_PI;
          while (diff < -Math.PI) diff += this.TWO_PI;
          return diff;
        };

        const predictIntersection = (slot, skill) => {
          const paddle = state.paddles[slot];
          if (!paddle) return null;
          const ball = state.ball;
          const bx = ball.x || ball.r * Math.cos(ball.theta);
          const by = ball.y || ball.r * Math.sin(ball.theta);
          const vx = ball.vr * Math.cos(ball.theta) - ball.r * (ball.vtheta || 0) * Math.sin(ball.theta);
          const vy = ball.vr * Math.sin(ball.theta) + ball.r * (ball.vtheta || 0) * Math.cos(ball.theta);

          for (let t = 1; t <= 40; t++) {
            const px = bx + vx * t * 1.5;
            const py = by + vy * t * 1.5;
            const pr = Math.sqrt(px * px + py * py);
            let pTheta = Math.atan2(py, px);
            if (pTheta < 0) pTheta += this.TWO_PI;
            if (Math.abs(angleDiff(pTheta, paddle.angle)) < HALF_PI / 2 && pr >= 0.7) {
              return pTheta + (Math.random() - 0.5) * 0.2 * (1 - skill);
            }
          }
          return paddle.angle;
        };

        for (let i = 0; i < 4; i++) {
          const slot = slots[i];
          const player = this.players[slot];

          // Skip if mode is off or external (external handled by ControlDeckBridge)
          if (player.mode !== 'internal') continue;

          const paddle = state.paddles[slot];
          if (!paddle) continue;

          const targetAngle = predictIntersection(slot, player.skill);
          if (targetAngle === null) continue;

          let desiredOffset = angleDiff(targetAngle, paddle.angle);
          const maxOffset = Math.PI / 5;
          desiredOffset = Math.max(-maxOffset, Math.min(maxOffset, desiredOffset));

          const currentOffset = paddle.offset || 0;
          const diff = desiredOffset - currentOffset;
          const threshold = 0.05 * (1 - player.skill);

          if (Math.abs(diff) > threshold) {
            axes[i] = Math.sign(diff) * Math.min(1, Math.abs(diff) * 3) * player.skill;
          }

          // Update UI - pulse on activity
          const btn = document.getElementById(`ai-${slot}`);
          if (btn && Math.abs(axes[i]) > 0.1) {
            btn.classList.add('active');
            setTimeout(() => btn.classList.remove('active'), 100);
          }
        }

        // Send inputs for internal AI
        for (let i = 0; i < 4; i++) {
          if (this.players[slots[i]].mode === 'internal' && Math.abs(axes[i]) > 0.01) {
            sendInput({
              t: 'input', src: 'ai', slot: slots[i],
              axis: axes[i], key: axes[i] > 0 ? 'cw' : 'ccw',
              val: Math.abs(axes[i]), pressed: true
            });
          }
        }
      }
    };

    // ========================================
    // GAMMA DETECTION
    // ========================================
    const Gamma = {
      available: false,
      async detect() {
        // Use relative URLs - requires access via Caddy proxy (:8080)
        try {
          const resp = await fetch('/api/status', {
            method: 'GET',
            signal: AbortSignal.timeout(2000)
          });
          this.available = resp.ok;
        } catch (e) {
          this.available = false;
        }
        return this.available;
      }
    };

    // ========================================
    // ANSI PARSER
    // ========================================
    const ANSI = {
      colors: {
        30: '#000', 31: '#a00', 32: '#0a0', 33: '#a50',
        34: '#00a', 35: '#a0a', 36: '#0aa', 37: '#aaa',
        90: '#555', 91: '#f55', 92: '#5f5', 93: '#ff5',
        94: '#55f', 95: '#f5f', 96: '#5ff', 97: '#fff'
      },
      toHtml(text) {
        if (!text) return '';
        let html = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        html = html.replace(/\x1b\[([0-9;]+)m/g, (match, codes) => {
          const parts = codes.split(';');
          let style = [], close = false;
          for (const code of parts) {
            const n = parseInt(code);
            if (n === 0) close = true;
            else if (n === 1) style.push('font-weight:bold');
            else if ((n >= 30 && n <= 37) || (n >= 90 && n <= 97))
              style.push('color:' + (this.colors[n] || '#fff'));
            else if (n >= 40 && n <= 47)
              style.push('background:' + (this.colors[n - 10] || '#000'));
          }
          if (close) return '</span>';
          if (style.length) return '<span style="' + style.join(';') + '">';
          return '';
        });
        return html;
      }
    };

    // ========================================
    // GAMMA BOOT SCREEN
    // ========================================
    const BootScreen = {
      LOGO: [
        '  ██████╗  █████╗ ███╗   ███╗███╗   ███╗ █████╗ ',
        ' ██╔════╝ ██╔══██╗████╗ ████║████╗ ████║██╔══██╗',
        ' ██║  ███╗███████║██╔████╔██║██╔████╔██║███████║',
        ' ██║   ██║██╔══██║██║╚██╔╝██║██║╚██╔╝██║██╔══██║',
        ' ╚██████╔╝██║  ██║██║ ╚═╝ ██║██║ ╚═╝ ██║██║  ██║',
        '  ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝',
      ],
      C: {
        reset: '\x1b[0m',
        cyan: '\x1b[36m',
        magenta: '\x1b[35m',
        brightMagenta: '\x1b[95m',
        brightCyan: '\x1b[96m',
        green: '\x1b[32m',
        dim: '\x1b[2m',
        yellow: '\x1b[33m',
      },

      render(width = 52, height = 20) {
        const { C, LOGO } = this;
        const lines = [];

        const center = (str, w) => {
          const visLen = str.replace(/\x1b\[[0-9;]*m/g, '').length;
          if (visLen >= w) return str;
          const pad = w - visLen;
          const left = Math.floor(pad / 2);
          return ' '.repeat(left) + str;
        };

        const padLine = (str, w) => {
          const visLen = str.replace(/\x1b\[[0-9;]*m/g, '').length;
          return str + ' '.repeat(Math.max(0, w - visLen));
        };

        const innerWidth = width - 4;

        // Top border
        lines.push(C.cyan + '╔' + '═'.repeat(width - 2) + '╗' + C.reset);
        lines.push(C.cyan + '║' + ' '.repeat(width - 2) + '║' + C.reset);

        // GAMMA logo (magenta)
        for (const logoLine of LOGO) {
          const centered = center(C.brightMagenta + logoLine + C.reset, innerWidth);
          lines.push(C.cyan + '║ ' + padLine(centered, innerWidth) + ' ║' + C.reset);
        }

        lines.push(C.cyan + '║' + ' '.repeat(width - 2) + '║' + C.reset);

        // Subtitle
        const subtitle = 'A N S I   C A B I N E T';
        lines.push(C.cyan + '║ ' + padLine(center(C.brightCyan + subtitle + C.reset, innerWidth), innerWidth) + ' ║' + C.reset);

        lines.push(C.cyan + '║' + ' '.repeat(width - 2) + '║' + C.reset);
        lines.push(C.cyan + '║' + ' '.repeat(width - 2) + '║' + C.reset);

        // Prompt
        const prompt = 'Enter code to connect';
        lines.push(C.cyan + '║ ' + padLine(center(C.dim + prompt + C.reset, innerWidth), innerWidth) + ' ║' + C.reset);

        lines.push(C.cyan + '║' + ' '.repeat(width - 2) + '║' + C.reset);

        // Bottom border
        lines.push(C.cyan + '╚' + '═'.repeat(width - 2) + '╝' + C.reset);

        return lines.join('\n');
      },

      show(displayEl) {
        displayEl.innerHTML = ANSI.toHtml(this.render());
      }
    };

    // ========================================
    // STUN FINGERPRINTING (behind flag)
    // ========================================
    // STUNFingerprint class loaded from lib/stun.js
    // CabinetConfig loaded from lib/config.js
    const stunFingerprint = new STUNFingerprint({
      enabled: CabinetConfig.flags.stun
    });

    // ========================================
    // STATE
    // ========================================
    let ws = null;
    let slot = null;
    let gameName = null;
    let matchCode = null;
    let matchExpires = null;
    let timerInterval = null;
    let wsUrl = null;

    const displayEl = document.getElementById('game-display');
    const gameNameEl = document.getElementById('game-name');
    const slotDisplayEl = document.getElementById('slot-display');
    const playersDisplayEl = document.getElementById('players-display');
    const timeRemainingEl = document.getElementById('time-remaining');
    const joinTargetEl = document.getElementById('join-target');
    const slotSelectEl = document.getElementById('slot-select');
    const nickInputEl = document.getElementById('nick-input');
    const joinBtn = document.getElementById('join-btn');
    const takeoverBtn = document.getElementById('takeover-btn');
    const resetBtn = document.getElementById('reset-btn');
    const extendBtn = document.getElementById('extend-btn');
    const startBtn = document.getElementById('start-btn');
    const controlStatusEl = document.getElementById('control-status');

    // ========================================
    // TIMER
    // ========================================
    function formatTime(ms) {
      if (ms <= 0) return '00:00';
      const secs = Math.floor(ms / 1000);
      const mins = Math.floor(secs / 60);
      return `${mins.toString().padStart(2, '0')}:${(secs % 60).toString().padStart(2, '0')}`;
    }

    function updateTimer() {
      if (!matchExpires) {
        timeRemainingEl.textContent = '--:--';
        timeRemainingEl.className = 'hw-value';
        return;
      }
      const remaining = matchExpires - Date.now();
      timeRemainingEl.textContent = formatTime(remaining);
      if (remaining <= 0) {
        timeRemainingEl.className = 'hw-value critical';
      } else if (remaining < 60000) {
        timeRemainingEl.className = 'hw-value critical';
      } else if (remaining < 180000) {
        timeRemainingEl.className = 'hw-value warning';
      } else {
        timeRemainingEl.className = 'hw-value';
      }
    }

    function startTimer(expires) {
      matchExpires = expires;
      updateTimer();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 1000);
    }

    function stopTimer() {
      matchExpires = null;
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      updateTimer();
    }

    // ========================================
    // CONTROLS
    // ========================================
    async function extendMatch() {
      if (!matchCode || !Gamma.available) return;
      try {
        const resp = await fetch(`/api/match/extend`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: matchCode })
        });
        const result = await resp.json();
        if (result.ok) {
          matchExpires = result.expires;
          updateTimer();
        }
      } catch (e) {
        console.error('[cabinet] Failed to extend:', e);
      }
    }

    function sendReset() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        // Send game reset command
        ws.send(JSON.stringify({ t: 'game.reset' }));
      }
    }

    function sendStart() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        // Send game play command (host expects 'game.play')
        ws.send(JSON.stringify({ t: 'game.play' }));
        controlStatusEl.textContent = 'Starting...';
        setTimeout(() => { controlStatusEl.textContent = ''; }, 2000);
      }
    }

    function sendTakeover() {
      const requestSlot = slotSelectEl.value;
      if (!requestSlot || !ws || ws.readyState !== WebSocket.OPEN) return;

      // Re-identify with takeover request
      ws.send(JSON.stringify({
        t: 'identify',
        cid: Cabinet.data.cid,
        nick: Cabinet.data.nick || undefined,
        visits: Cabinet.data.visits,
        requestSlot: requestSlot,
        takeover: true
      }));
    }

    // ========================================
    // CONNECTION
    // ========================================
    function updateSlotDisplay() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        slotDisplayEl.textContent = 'OFFLINE';
        slotDisplayEl.style.color = '#666';
      } else if (slot) {
        const label = slot === 'spectator' ? 'SPECTATOR' : slot.toUpperCase();
        slotDisplayEl.textContent = label + (matchCode ? ` [${matchCode}]` : '');
        slotDisplayEl.style.color = slot === 'spectator' ? '#666' : '#0ff';
      }
    }

    function updatePlayersDisplay(players) {
      if (!players || players.length === 0) {
        playersDisplayEl.textContent = '';
        return;
      }
      playersDisplayEl.innerHTML = players.map(p => {
        const isMe = p.cid === Cabinet.data.cid;
        const color = isMe ? '#0ff' : '#050';
        const name = p.nick || p.cid?.substring(0, 6) || 'anon';
        return `<span style="color:${color}">${p.slot.toUpperCase()}:${name}</span>`;
      }).join(' ');
    }

    function updateGameName(name) {
      gameName = name;
      gameNameEl.textContent = name || '---';
      document.title = name ? `${name} | ANSI Cabinet` : 'ANSI Cabinet';
      // Update bridge with game type for game-specific channel
      if (name && ControlDeckBridge.enabled) {
        ControlDeckBridge.setGame(name);
      }
    }

    async function smartJoin() {
      const input = joinTargetEl.value.trim();
      if (!input) return;

      if (input.startsWith('ws://') || input.startsWith('wss://')) {
        wsUrl = input;
        connect();
      } else if (input.includes(':') && /:\d+$/.test(input)) {
        wsUrl = `ws://${input}`;
        connect();
      } else {
        await joinByCode(input.toUpperCase());
      }
    }

    async function joinByCode(code) {
      if (!Gamma.available) {
        slotDisplayEl.textContent = 'NO GAMMA';
        return;
      }

      matchCode = code;
      slotDisplayEl.textContent = 'RESOLVING...';

      try {
        const resp = await fetch(`/api/match/join`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code })
        });

        if (!resp.ok) {
          slotDisplayEl.textContent = 'NOT FOUND';
          return;
        }

        const data = await resp.json();
        if (data.host) {
          wsUrl = data.host.startsWith('ws://') ? data.host : `ws://${data.host}`;
          if (data.game) updateGameName(data.game.toUpperCase());

          // Get match expiration
          try {
            const matchResp = await fetch(`/api/match/${code}`);
            if (matchResp.ok) {
              const info = await matchResp.json();
              if (info.expires) startTimer(info.expires);
            }
          } catch (e) {}

          connect();
        }
      } catch (e) {
        slotDisplayEl.textContent = 'ERROR';
      }
    }

    function connect() {
      if (!wsUrl) return;
      if (ws) ws.close();

      slotDisplayEl.textContent = 'CONNECTING...';
      ws = new WebSocket(wsUrl);

      ws.onopen = async () => {
        const nickVal = nickInputEl.value.trim();
        if (nickVal) Cabinet.setNick(nickVal);

        // Query STUN for public address (if enabled)
        const stunInfo = await stunFingerprint.getPublicAddress();

        const requestSlot = slotSelectEl.value;
        const identifyMsg = {
          t: 'identify',
          cid: Cabinet.data.cid,
          nick: Cabinet.data.nick || undefined,
          visits: Cabinet.data.visits,
          requestSlot: requestSlot,
          takeover: ['p1', 'p2', 'p3', 'p4'].includes(requestSlot),
          stun: stunInfo  // null if disabled or failed
        };
        // For generic server mode, include selected game
        if (isGenericServer && selectedGameId) {
          identifyMsg.game = selectedGameId;
        }
        ws.send(JSON.stringify(identifyMsg));
      };

      ws.onmessage = (e) => {
        try {
          handleMessage(JSON.parse(e.data));
        } catch (err) {}
      };

      ws.onclose = () => {
        slot = null;
        updateSlotDisplay();
        updatePlayersDisplay([]);
        stopTimer();
        takeoverBtn.disabled = true;
      };

      ws.onerror = () => {
        slotDisplayEl.textContent = 'ERROR';
      };
    }

    function handleMessage(data) {
      if (data.t === 'welcome') {
        slot = data.slot;
        Cabinet.recordSlot(slot);
        updateSlotDisplay();
        if (data.game) updateGameName(data.game.toUpperCase());
        if (data.players) updatePlayersDisplay(data.players);
        // Enable takeover if we're spectator or want to switch
        takeoverBtn.disabled = false;
      } else if (data.t === 'players') {
        updatePlayersDisplay(data.players || []);
      } else if (data.t === 'takeover') {
        if (data.oldCid === Cabinet.data.cid) {
          slot = 'spectator';
          updateSlotDisplay();
        }
      } else if (data.t === 'frame') {
        displayEl.innerHTML = ANSI.toHtml(data.display || '');
        if (data.game && !gameName) updateGameName(data.game.toUpperCase());
        // Bridge: broadcast state to ControlDeck
        if (data.state && ControlDeckBridge.enabled) {
          ControlDeckBridge.broadcastState(data.state, gameName);
        }
        // Feed state to local AI
        if (data.state) {
          LocalAI.updateState(data.state);
        }
      }
    }

    // ========================================
    // INPUT
    // ========================================
    function sendInput(msg) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(msg));
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
        e.preventDefault();
      }
      // Send both e.key and e.code for compatibility with different games
      sendInput({ t: 'input', src: 'keyboard', key: e.key, ctrl: e.code, val: 1, pressed: true });
    });

    document.addEventListener('keyup', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      sendInput({ t: 'input', src: 'keyboard', key: e.key, ctrl: e.code, val: 0, pressed: false });
    });

    // Gamepad
    let gamepadPollId = null;
    const lastGamepadState = {};

    function pollGamepads() {
      const gamepads = navigator.getGamepads();
      for (const gp of gamepads) {
        if (!gp) continue;
        const last = lastGamepadState[gp.index] || { axes: [], buttons: [] };

        for (let i = 0; i < gp.axes.length; i++) {
          const val = gp.axes[i];
          if (Math.abs(val - (last.axes[i] || 0)) > 0.01) {
            const ctrl = ['left-x', 'left-y', 'right-x', 'right-y'][i] || `axis-${i}`;
            sendInput({ t: 'input', src: 'gamepad', ctrl, val });
          }
          last.axes[i] = val;
        }

        for (let i = 0; i < gp.buttons.length; i++) {
          const btn = gp.buttons[i];
          const wasPressed = last.buttons[i] || false;
          if (btn.pressed !== wasPressed) {
            const ctrl = ['a', 'b', 'x', 'y', 'l1', 'r1', 'l2', 'r2',
              'select', 'start', 'l3', 'r3',
              'dpad-up', 'dpad-down', 'dpad-left', 'dpad-right', 'home'][i] || `button-${i}`;
            sendInput({ t: 'input', src: 'gamepad', ctrl, val: btn.pressed ? 1 : 0, pressed: btn.pressed });
          }
          last.buttons[i] = btn.pressed;
        }
        lastGamepadState[gp.index] = last;
      }
      gamepadPollId = requestAnimationFrame(pollGamepads);
    }

    window.addEventListener('gamepadconnected', () => {
      if (!gamepadPollId) pollGamepads();
    });

    // ========================================
    // GAME SELECTION MODAL
    // ========================================
    const gameModal = document.getElementById('game-modal');
    const gameListEl = document.getElementById('game-list');
    let availableGames = [];
    let isGenericServer = false;

    async function fetchGames() {
      try {
        const resp = await fetch('/api/games');
        if (resp.ok) {
          availableGames = await resp.json();
          return availableGames;
        }
      } catch (e) {
        console.log('[cabinet] Could not fetch games list');
      }
      return [];
    }

    function openGameModal() {
      if (!isGenericServer || availableGames.length === 0) return;

      gameListEl.innerHTML = availableGames.map(game => `
        <div class="game-option" onclick="selectGame('${game.id || game.name}')">
          <span class="game-title">${(game.name || game.id || 'Unknown').toUpperCase()}</span>
          <span class="game-players">${game.players || '1-4'} players</span>
        </div>
      `).join('');

      gameModal.classList.add('visible');
    }

    function closeGameModal() {
      gameModal.classList.remove('visible');
    }

    function selectGame(gameId) {
      closeGameModal();
      updateGameName(gameId.toUpperCase());
      // For generic server, we need to tell it which game to load
      // This will be passed in the identify message
      selectedGameId = gameId;
    }

    let selectedGameId = null;

    // Detect if we're on a generic server vs dedicated game port
    function detectServerMode() {
      const port = parseInt(location.port);
      // Dedicated game ports are 1600-1855
      if (port >= 1600 && port <= 1855) {
        isGenericServer = false;
        gameNameEl.classList.remove('clickable');
      } else {
        isGenericServer = true;
        gameNameEl.classList.add('clickable');
        fetchGames();
      }
    }

    // ========================================
    // EVENT BINDINGS
    // ========================================
    gameNameEl.addEventListener('click', openGameModal);
    joinBtn.addEventListener('click', smartJoin);
    joinTargetEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') smartJoin(); });
    resetBtn.addEventListener('click', sendReset);
    extendBtn.addEventListener('click', extendMatch);
    takeoverBtn.addEventListener('click', sendTakeover);
    startBtn.addEventListener('click', sendStart);

    slotSelectEl.addEventListener('change', () => {
      const val = slotSelectEl.value;
      takeoverBtn.disabled = !val || !ws || ws.readyState !== WebSocket.OPEN;
    });

    // AI controls - per-player triple-toggle buttons
    ['p1', 'p2', 'p3', 'p4'].forEach(slot => {
      document.getElementById(`ai-${slot}`).addEventListener('click', () => {
        LocalAI.cycleMode(slot);
      });
    });

    document.getElementById('ai-skill').addEventListener('input', (e) => {
      const skill = parseFloat(e.target.value);
      document.getElementById('ai-skill-val').textContent = skill.toFixed(1);
      if (LocalAI.selectedSlot) {
        LocalAI.setSkill(LocalAI.selectedSlot, skill);
      }
    });

    // ========================================
    // INIT
    // ========================================
    async function init() {
      // Show GAMMA boot screen
      BootScreen.show(displayEl);

      // Initialize ControlDeck bridge for AI integration
      ControlDeckBridge.init();

      // Initialize local AI (tick loop always runs, checks per-player modes)
      LocalAI.init();

      // Detect server mode (generic vs dedicated game port)
      detectServerMode();

      await Gamma.detect();

      if (Cabinet.data.nick) {
        nickInputEl.value = Cabinet.data.nick;
      }

      const params = new URLSearchParams(location.search);

      // Check for match code in URL path: /match/XXXX/
      const pathMatch = location.pathname.match(/\/match\/([A-Z0-9]{4})\/?/i);

      if (pathMatch) {
        // URL path contains match code (e.g., /match/HHAJ/)
        const code = pathMatch[1].toUpperCase();
        joinTargetEl.value = code;
        matchCode = code;
        setTimeout(() => joinByCode(code), 100);
      } else if (params.has('host')) {
        const host = params.get('host');
        wsUrl = host.startsWith('ws://') ? host : `ws://${host}`;
        // Don't show host:port, extract code if present
        const codeMatch = host.match(/([A-Z0-9]{4})$/i);
        joinTargetEl.value = codeMatch ? codeMatch[1].toUpperCase() : '';
        setTimeout(connect, 100);
      } else if (params.has('code')) {
        const code = params.get('code').toUpperCase();
        joinTargetEl.value = code;
        setTimeout(() => joinByCode(code), 100);
      } else if (location.hostname && location.port) {
        // Auto-detect: we're being served from a game server
        // Connect via WebSocket but don't show host:port in input
        const autoUrl = `ws://${location.host}`;
        wsUrl = autoUrl;
        joinTargetEl.value = 'LOCL';
        setTimeout(connect, 100);
      }
    }

    init();
  </script>
</body>
</html>
