<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GAMMA Cabinet</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #888;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }

    /* ========================================
       HEADER BAR
       ======================================== */
    #header {
      width: 100%;
      max-width: 640px;
      background: linear-gradient(180deg, #1a0a1a 0%, #0a0a1a 100%);
      border: 2px solid #606;
      padding: 8px 12px;
      margin-bottom: 0;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #gamma-logo {
      font-size: 14px;
      font-weight: bold;
      color: #f0f;
      text-decoration: none;
      letter-spacing: 1px;
    }
    #gamma-logo:hover { color: #f5f; }
    #match-code {
      font-size: 16px;
      font-weight: bold;
      color: #0ff;
      letter-spacing: 2px;
      min-width: 60px;
    }
    #match-code.offline { color: #444; }
    .timer-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #time-remaining {
      font-size: 14px;
      color: #0f0;
      min-width: 45px;
    }
    #time-remaining.warning { color: #f80; }
    #time-remaining.critical { color: #f00; animation: blink 0.5s infinite; }
    @keyframes blink { 50% { opacity: 0.3; } }
    #extend-btn {
      font-family: 'Courier New', monospace;
      font-size: 10px;
      padding: 2px 6px;
      background: #1a1a1a;
      color: #666;
      border: 1px solid #333;
      cursor: pointer;
    }
    #extend-btn:hover { background: #222; color: #0f0; border-color: #0a0; }
    #game-name {
      flex: 1;
      text-align: right;
      font-size: 12px;
      color: #0ff;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    #reset-btn {
      width: 28px;
      height: 28px;
      background: #200;
      border: 2px solid #500;
      color: #800;
      font-weight: bold;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #reset-btn:hover { background: #300; color: #f00; border-color: #700; }
    #reset-btn:active { background: #500; color: #fff; }

    /* ========================================
       GAME DISPLAY
       ======================================== */
    #game-display {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.15;
      white-space: pre;
      background: #000;
      padding: 8px;
      border: 2px solid #333;
      border-top: none;
      min-width: 500px;
      min-height: 300px;
      max-width: 640px;
      width: 100%;
      color: #0f0;
    }

    /* ========================================
       CONTROL BAR
       ======================================== */
    #control-bar {
      width: 100%;
      max-width: 640px;
      background: #111;
      border: 2px solid #333;
      border-top: none;
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    /* D-Pad */
    .dpad {
      display: grid;
      grid-template-columns: 24px 24px 24px;
      grid-template-rows: 24px 24px 24px;
      gap: 2px;
    }
    .dpad-btn {
      background: #1a1a1a;
      border: 1px solid #333;
      color: #333;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.1s;
    }
    .dpad-btn:hover { background: #222; }
    .dpad-btn.active { background: #030; color: #0f0; border-color: #0f0; }
    .dpad-up { grid-column: 2; grid-row: 1; border-radius: 4px 4px 0 0; }
    .dpad-down { grid-column: 2; grid-row: 3; border-radius: 0 0 4px 4px; }
    .dpad-left { grid-column: 1; grid-row: 2; border-radius: 4px 0 0 4px; }
    .dpad-right { grid-column: 3; grid-row: 2; border-radius: 0 4px 4px 0; }
    .dpad-center { grid-column: 2; grid-row: 2; background: #0a0a0a; border-color: #222; cursor: default; }

    /* Game Control Buttons */
    .game-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    #play-btn {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      padding: 10px 24px;
      background: #020;
      color: #0a0;
      border: 2px solid #0a0;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 3px;
      font-weight: bold;
    }
    #play-btn:hover { background: #030; color: #0f0; border-color: #0f0; }
    #play-btn:active { background: #050; }
    #play-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    #ctrl-reset-btn {
      font-family: 'Courier New', monospace;
      font-size: 10px;
      padding: 6px 12px;
      background: #200;
      color: #800;
      border: 1px solid #500;
      cursor: pointer;
      text-transform: uppercase;
    }
    #ctrl-reset-btn:hover { background: #300; color: #f00; border-color: #700; }

    /* Action Buttons */
    .action-buttons {
      display: grid;
      grid-template-columns: 28px 28px;
      grid-template-rows: 28px 28px;
      gap: 3px;
    }
    .action-btn {
      background: #1a1a1a;
      border: 1px solid #333;
      color: #333;
      font-size: 10px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.1s;
    }
    .action-btn:hover { background: #222; }
    .action-btn.active { background: #030; color: #0f0; border-color: #0f0; }
    .btn-a { color: #393; border-color: #393; }
    .btn-b { color: #933; border-color: #933; }
    .btn-x { color: #339; border-color: #339; }
    .btn-y { color: #993; border-color: #993; }

    /* ========================================
       PLAYER DECK
       ======================================== */
    #player-deck {
      width: 100%;
      max-width: 640px;
      background: #0c0c0c;
      border: 2px solid #333;
      border-top: none;
      padding: 12px 16px;
      display: flex;
      justify-content: center;
      gap: 12px;
    }
    .player-slot {
      width: 100px;
      background: #111;
      border: 2px solid #333;
      padding: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s;
    }
    .player-slot:hover { border-color: #555; }
    .player-slot.none { border-color: #333; }
    .player-slot.int { border-color: #0a0; }
    .player-slot.ext { border-color: #06f; }
    .player-slot.you { border-color: #0ff; background: #0a1a1a; }
    .player-slot.human { border-color: #f80; }
    .player-label {
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 6px;
    }
    .player-slot.none .player-label { color: #444; }
    .player-slot.int .player-label { color: #0f0; }
    .player-slot.ext .player-label { color: #0af; }
    .player-slot.you .player-label { color: #0ff; }
    .player-slot.human .player-label { color: #f80; }

    /* Paddle indicator */
    .paddle-display {
      height: 40px;
      margin: 6px 0;
      position: relative;
      background: #0a0a0a;
      border: 1px solid #222;
    }
    .paddle-track {
      position: absolute;
      left: 50%;
      top: 4px;
      bottom: 4px;
      width: 2px;
      background: #222;
      transform: translateX(-50%);
    }
    .paddle-knob {
      position: absolute;
      left: 50%;
      width: 20px;
      height: 6px;
      background: #333;
      border-radius: 2px;
      transform: translateX(-50%);
      top: 50%;
      margin-top: -3px;
      transition: top 0.05s;
    }
    .player-slot.int .paddle-knob { background: #0a0; }
    .player-slot.ext .paddle-knob { background: #06f; }
    .player-slot.you .paddle-knob { background: #0ff; }
    .player-slot.human .paddle-knob { background: #f80; }

    .player-state {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 3px 6px;
      background: #1a1a1a;
      border-radius: 2px;
    }
    .player-slot.none .player-state { color: #444; }
    .player-slot.int .player-state { color: #0f0; background: #010; }
    .player-slot.ext .player-state { color: #0af; background: #001; }
    .player-slot.you .player-state { color: #0ff; background: #011; }
    .player-slot.human .player-state { color: #f80; background: #110; }

    /* ========================================
       CONNECT BAR
       ======================================== */
    #connect-bar {
      width: 100%;
      max-width: 640px;
      background: #0a0a0a;
      border: 2px solid #222;
      border-top: none;
      padding: 10px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #connect-bar label {
      font-size: 10px;
      color: #555;
      text-transform: uppercase;
    }
    #code-input {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      padding: 6px 10px;
      background: #111;
      color: #0f0;
      border: 1px solid #333;
      width: 80px;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
    }
    #code-input:focus { outline: none; border-color: #0a0; }
    #connect-btn {
      font-family: 'Courier New', monospace;
      font-size: 11px;
      padding: 6px 14px;
      background: #020;
      color: #0a0;
      border: 1px solid #0a0;
      cursor: pointer;
      text-transform: uppercase;
    }
    #connect-btn:hover { background: #030; color: #0f0; }
    .spacer { flex: 1; }
    #nick-display {
      font-size: 11px;
      color: #666;
    }
    #nick-display span { color: #0ff; cursor: pointer; }
    #nick-display span:hover { text-decoration: underline; }
    #connection-status {
      font-size: 10px;
      color: #444;
    }
    #connection-status.connected { color: #0f0; }
    #connection-status.error { color: #f00; }
  </style>
</head>
<body>

  <!-- Header: GAMMA | CODE | TIMER | GAME | RESET -->
  <div id="header">
    <a id="gamma-logo" href="/" title="GAMMA Lobby">GAMMA</a>
    <span id="match-code" class="offline">----</span>
    <div class="timer-group">
      <span id="time-remaining">--:--</span>
      <button id="extend-btn" title="Extend +5 minutes">+5M</button>
    </div>
    <span id="game-name">---</span>
    <button id="reset-btn" title="Reset Game">R</button>
  </div>

  <!-- Game Display -->
  <pre id="game-display"></pre>

  <!-- Control Bar: D-PAD | PLAY/RESET | ACTION BUTTONS -->
  <div id="control-bar">
    <div class="dpad">
      <button class="dpad-btn dpad-up" data-dir="up">▲</button>
      <button class="dpad-btn dpad-left" data-dir="left">◄</button>
      <div class="dpad-btn dpad-center">●</div>
      <button class="dpad-btn dpad-right" data-dir="right">►</button>
      <button class="dpad-btn dpad-down" data-dir="down">▼</button>
    </div>

    <div class="game-controls">
      <button id="play-btn">▶ PLAY</button>
      <button id="ctrl-reset-btn">RESET</button>
    </div>

    <div class="action-buttons">
      <button class="action-btn btn-a" data-btn="a">A</button>
      <button class="action-btn btn-b" data-btn="b">B</button>
      <button class="action-btn btn-x" data-btn="x">X</button>
      <button class="action-btn btn-y" data-btn="y">Y</button>
    </div>
  </div>

  <!-- Player Deck -->
  <div id="player-deck">
    <div class="player-slot none" data-slot="p1">
      <div class="player-label">P1</div>
      <div class="paddle-display">
        <div class="paddle-track"></div>
        <div class="paddle-knob" id="paddle-p1"></div>
      </div>
      <div class="player-state">NONE</div>
    </div>
    <div class="player-slot none" data-slot="p2">
      <div class="player-label">P2</div>
      <div class="paddle-display">
        <div class="paddle-track"></div>
        <div class="paddle-knob" id="paddle-p2"></div>
      </div>
      <div class="player-state">NONE</div>
    </div>
    <div class="player-slot none" data-slot="p3">
      <div class="player-label">P3</div>
      <div class="paddle-display">
        <div class="paddle-track"></div>
        <div class="paddle-knob" id="paddle-p3"></div>
      </div>
      <div class="player-state">NONE</div>
    </div>
    <div class="player-slot none" data-slot="p4">
      <div class="player-label">P4</div>
      <div class="paddle-display">
        <div class="paddle-track"></div>
        <div class="paddle-knob" id="paddle-p4"></div>
      </div>
      <div class="player-state">NONE</div>
    </div>
  </div>

  <!-- Connect Bar -->
  <div id="connect-bar">
    <label>CODE</label>
    <input type="text" id="code-input" placeholder="XXXX" maxlength="4" autocomplete="off">
    <button id="connect-btn">CONNECT</button>
    <div class="spacer"></div>
    <div id="nick-display">Nick: <span id="nick-value">---</span></div>
    <div id="connection-status">OFFLINE</div>
  </div>

  <script>
    // ========================================
    // ANSI TO HTML CONVERTER
    // ========================================
    const ANSI_COLORS = {
      '30': '#000', '31': '#a00', '32': '#0a0', '33': '#a50',
      '34': '#00a', '35': '#a0a', '36': '#0aa', '37': '#aaa',
      '90': '#555', '91': '#f55', '92': '#5f5', '93': '#ff5',
      '94': '#55f', '95': '#f5f', '96': '#5ff', '97': '#fff',
      '40': '#000', '41': '#a00', '42': '#0a0', '43': '#a50',
      '44': '#00a', '45': '#a0a', '46': '#0aa', '47': '#aaa'
    };

    function ansiToHtml(text) {
      if (!text) return '';
      let html = '';
      let currentColor = null;
      let i = 0;

      while (i < text.length) {
        // Check for ANSI escape sequence
        if (text[i] === '\x1b' && text[i + 1] === '[') {
          // Find the end of the sequence
          let j = i + 2;
          while (j < text.length && text[j] !== 'm') j++;

          if (text[j] === 'm') {
            const codes = text.slice(i + 2, j).split(';');

            // Close previous span if open
            if (currentColor) {
              html += '</span>';
              currentColor = null;
            }

            // Process codes
            for (const code of codes) {
              if (code === '0' || code === '') {
                // Reset
                currentColor = null;
              } else if (ANSI_COLORS[code]) {
                // Foreground color (30-37, 90-97)
                if (parseInt(code) < 40 || parseInt(code) >= 90) {
                  currentColor = ANSI_COLORS[code];
                  html += `<span style="color:${currentColor}">`;
                }
              } else if (code === '1') {
                // Bold - brighten
                currentColor = currentColor || '#fff';
              } else if (code === '2') {
                // Dim
                currentColor = currentColor || '#666';
              }
            }

            i = j + 1;
            continue;
          }
        }

        // Escape HTML entities
        if (text[i] === '<') html += '&lt;';
        else if (text[i] === '>') html += '&gt;';
        else if (text[i] === '&') html += '&amp;';
        else html += text[i];

        i++;
      }

      // Close any open span
      if (currentColor) html += '</span>';

      return html;
    }

    // ========================================
    // CABINET IDENTITY
    // ========================================
    const Cabinet = {
      init() {
        let data = localStorage.getItem('cabinet');
        if (data) {
          this.data = JSON.parse(data);
          this.data.visits++;
          this.data.lastSeen = Date.now();
        } else {
          this.data = {
            cid: 'cab_' + Math.random().toString(36).substr(2, 6),
            nick: 'Player' + Math.floor(Math.random() * 100),
            visits: 1,
            firstSeen: Date.now(),
            lastSeen: Date.now()
          };
        }
        this.save();
        return this;
      },
      save() { localStorage.setItem('cabinet', JSON.stringify(this.data)); },
      setNick(nick) { this.data.nick = nick.substring(0, 12); this.save(); }
    }.init();

    // ========================================
    // STATE
    // ========================================
    let ws = null;
    let wsUrl = null;
    let matchCode = null;
    let matchExpires = null;
    let timerInterval = null;
    let mySlot = null;
    let gameName = null;
    let playerStates = { p1: 'none', p2: 'none', p3: 'none', p4: 'none' };
    let paddlePositions = { p1: 0.5, p2: 0.5, p3: 0.5, p4: 0.5 };

    // ========================================
    // DOM ELEMENTS
    // ========================================
    const matchCodeEl = document.getElementById('match-code');
    const timeRemainingEl = document.getElementById('time-remaining');
    const extendBtn = document.getElementById('extend-btn');
    const gameNameEl = document.getElementById('game-name');
    const resetBtn = document.getElementById('reset-btn');
    const gameDisplayEl = document.getElementById('game-display');
    const playBtn = document.getElementById('play-btn');
    const ctrlResetBtn = document.getElementById('ctrl-reset-btn');
    const codeInput = document.getElementById('code-input');
    const connectBtn = document.getElementById('connect-btn');
    const nickValueEl = document.getElementById('nick-value');
    const connectionStatusEl = document.getElementById('connection-status');
    const playerSlots = document.querySelectorAll('.player-slot');
    const dpadBtns = document.querySelectorAll('.dpad-btn[data-dir]');
    const actionBtns = document.querySelectorAll('.action-btn');

    // ========================================
    // TIMER
    // ========================================
    function updateTimer() {
      if (!matchExpires) {
        timeRemainingEl.textContent = '--:--';
        timeRemainingEl.className = '';
        return;
      }
      const remaining = Math.max(0, matchExpires - Date.now());
      const mins = Math.floor(remaining / 60000);
      const secs = Math.floor((remaining % 60000) / 1000);
      timeRemainingEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;

      if (remaining < 60000) {
        timeRemainingEl.className = 'critical';
      } else if (remaining < 120000) {
        timeRemainingEl.className = 'warning';
      } else {
        timeRemainingEl.className = '';
      }
    }

    function startTimer(expires) {
      matchExpires = expires;
      updateTimer();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 1000);
    }

    // ========================================
    // PLAYER DECK
    // ========================================
    function updatePlayerSlot(slot, state, name) {
      const el = document.querySelector(`.player-slot[data-slot="${slot}"]`);
      if (!el) return;

      el.className = `player-slot ${state}`;
      const stateEl = el.querySelector('.player-state');

      if (state === 'you') {
        stateEl.textContent = name || 'YOU';
      } else if (state === 'human') {
        stateEl.textContent = name || 'HUMAN';
      } else if (state === 'int') {
        stateEl.textContent = 'INT AI';
      } else if (state === 'ext') {
        stateEl.textContent = 'EXT AI';
      } else {
        stateEl.textContent = 'NONE';
      }

      playerStates[slot] = state;
    }

    function updatePaddlePosition(slot, position) {
      // position: 0 = top, 1 = bottom, 0.5 = center
      const knob = document.getElementById(`paddle-${slot}`);
      if (knob) {
        const top = 4 + (position * 24); // 4px to 28px range
        knob.style.top = `${top}px`;
        knob.style.marginTop = '0';
      }
      paddlePositions[slot] = position;
    }

    function cyclePlayerState(slot) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      const current = playerStates[slot];

      // State transitions:
      // NONE -> take over as human (YOU)
      // INT  -> take over as human (YOU)
      // EXT  -> take over as human (YOU)
      // YOU  -> release to INT AI
      // HUMAN (other player) -> can't take over

      if (current === 'human') {
        // Can't take over another human's slot
        return;
      }

      if (current === 'you') {
        // Release our slot - cycle to AI
        ws.send(JSON.stringify({
          t: 'slot.setAI',
          slot,
          mode: 'int'  // Release to internal AI
        }));
        updatePlayerSlot(slot, 'int');
      } else {
        // Take over this slot (none, int, or ext)
        ws.send(JSON.stringify({
          t: 'identify',
          cid: Cabinet.data.cid,
          nick: Cabinet.data.nick,
          visits: Cabinet.data.visits,
          requestSlot: slot,
          takeover: true
        }));
      }
    }

    // Long press on player slot cycles AI modes: int -> ext -> none -> int
    function cycleAIMode(slot) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      const current = playerStates[slot];
      if (current === 'you' || current === 'human') return;

      const next = { 'none': 'int', 'int': 'ext', 'ext': 'none' }[current] || 'int';
      ws.send(JSON.stringify({ t: 'slot.setAI', slot, mode: next }));
      updatePlayerSlot(slot, next);
    }

    // ========================================
    // CONTROLS
    // ========================================
    function sendPlay() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ t: 'game.play' }));
      }
    }

    function sendReset() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ t: 'game.reset' }));
      }
    }

    async function extendMatch() {
      if (!matchCode) return;
      try {
        const resp = await fetch('/api/match/extend', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: matchCode })
        });
        const result = await resp.json();
        if (result.ok && result.expires) {
          startTimer(result.expires);
        }
      } catch (e) {
        console.error('[cabinet] Extend failed:', e);
      }
    }

    function sendInput(key, pressed) {
      if (ws && ws.readyState === WebSocket.OPEN && mySlot) {
        ws.send(JSON.stringify({ t: 'input', key, pressed }));
      }
    }

    // D-pad visual feedback
    function setDpadActive(dir, active) {
      const btn = document.querySelector(`.dpad-btn[data-dir="${dir}"]`);
      if (btn) btn.classList.toggle('active', active);
    }

    // ========================================
    // CONNECTION
    // ========================================
    function updateConnectionStatus(status, isError = false) {
      connectionStatusEl.textContent = status;
      connectionStatusEl.className = isError ? 'error' : (status === 'CONNECTED' ? 'connected' : '');
    }

    function updateMatchCode(code) {
      matchCode = code;
      matchCodeEl.textContent = code || '----';
      matchCodeEl.classList.toggle('offline', !code);
    }

    async function joinByCode(code) {
      updateConnectionStatus('RESOLVING...');
      try {
        const resp = await fetch('/api/match/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: code.toUpperCase() })
        });

        if (!resp.ok) {
          updateConnectionStatus('NOT FOUND', true);
          return;
        }

        const data = await resp.json();
        if (data.error) {
          updateConnectionStatus(data.error, true);
          return;
        }

        if (data.host) {
          wsUrl = data.host.startsWith('ws://') ? data.host : `ws://${data.host}`;
          if (data.game) {
            gameName = data.game.toUpperCase();
            gameNameEl.textContent = gameName;
          }
          updateMatchCode(code.toUpperCase());

          // Get match info for timer
          try {
            const infoResp = await fetch(`/api/match/${code}`);
            if (infoResp.ok) {
              const info = await infoResp.json();
              if (info.expires) startTimer(info.expires);
            }
          } catch (e) {}

          connect();
        }
      } catch (e) {
        updateConnectionStatus('ERROR', true);
      }
    }

    function connect() {
      if (!wsUrl) return;
      if (ws) ws.close();

      updateConnectionStatus('CONNECTING...');
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        ws.send(JSON.stringify({
          t: 'identify',
          cid: Cabinet.data.cid,
          nick: Cabinet.data.nick,
          visits: Cabinet.data.visits,
          requestSlot: 'AUTO',
          takeover: false
        }));
      };

      ws.onmessage = (e) => {
        try {
          handleMessage(JSON.parse(e.data));
        } catch (err) {
          console.error('[cabinet] Message parse error:', err);
        }
      };

      ws.onclose = () => {
        mySlot = null;
        updateConnectionStatus('DISCONNECTED');
        // Reset player states
        ['p1', 'p2', 'p3', 'p4'].forEach(s => updatePlayerSlot(s, 'none'));
      };

      ws.onerror = () => {
        updateConnectionStatus('ERROR', true);
      };
    }

    function handleMessage(msg) {
      switch (msg.t) {
        case 'welcome':
          mySlot = msg.slot;
          updateConnectionStatus('CONNECTED');
          if (msg.game) {
            gameName = msg.game.toUpperCase();
            gameNameEl.textContent = gameName;
          }
          // Update player states from welcome
          if (msg.players) {
            msg.players.forEach(p => {
              const state = p.cid === Cabinet.data.cid ? 'you' : 'human';
              updatePlayerSlot(p.slot, state, p.nick);
            });
          }
          break;

        case 'frame':
          if (msg.display) {
            gameDisplayEl.innerHTML = ansiToHtml(msg.display);
          }
          // Update paddle positions from state
          if (msg.state && msg.state.paddles) {
            for (const [slot, paddle] of Object.entries(msg.state.paddles)) {
              // Normalize offset to 0-1 range
              const pos = 0.5 + (paddle.offset / 0.63); // paddleMaxOffset ≈ 0.63
              updatePaddlePosition(slot, Math.max(0, Math.min(1, pos)));
            }
          }
          break;

        case 'player.join':
          const joinState = msg.cid === Cabinet.data.cid ? 'you' : 'human';
          updatePlayerSlot(msg.slot, joinState, msg.nick);
          break;

        case 'player.leave':
          updatePlayerSlot(msg.slot, 'none');
          break;

        case 'slot.assigned':
          mySlot = msg.slot;
          updatePlayerSlot(msg.slot, 'you', Cabinet.data.nick);
          break;
      }
    }

    // ========================================
    // KEYBOARD INPUT
    // ========================================
    const keyMap = {
      'KeyW': 'up', 'ArrowUp': 'up',
      'KeyS': 'down', 'ArrowDown': 'down',
      'KeyA': 'left', 'ArrowLeft': 'left',
      'KeyD': 'right', 'ArrowRight': 'right',
      'Space': 'a', 'Enter': 'a',
      'KeyZ': 'a', 'KeyX': 'b',
      'KeyC': 'x', 'KeyV': 'y'
    };

    const activeKeys = new Set();

    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT') return;

      const action = keyMap[e.code];
      if (action && !activeKeys.has(e.code)) {
        activeKeys.add(e.code);
        setDpadActive(action, true);

        // Map to game keys
        const gameKey = {
          'up': 'w', 'down': 's', 'left': 'a', 'right': 'd',
          'a': ' ', 'b': 'x', 'x': 'c', 'y': 'v'
        }[action];
        if (gameKey) sendInput(gameKey, true);

        e.preventDefault();
      }
    });

    document.addEventListener('keyup', (e) => {
      const action = keyMap[e.code];
      if (action && activeKeys.has(e.code)) {
        activeKeys.delete(e.code);
        setDpadActive(action, false);

        const gameKey = {
          'up': 'w', 'down': 's', 'left': 'a', 'right': 'd',
          'a': ' ', 'b': 'x', 'x': 'c', 'y': 'v'
        }[action];
        if (gameKey) sendInput(gameKey, false);
      }
    });

    // ========================================
    // EVENT LISTENERS
    // ========================================
    playBtn.addEventListener('click', sendPlay);
    ctrlResetBtn.addEventListener('click', sendReset);
    resetBtn.addEventListener('click', sendReset);
    extendBtn.addEventListener('click', extendMatch);

    connectBtn.addEventListener('click', () => {
      const code = codeInput.value.trim();
      if (code.length === 4) {
        joinByCode(code);
      }
    });

    codeInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const code = codeInput.value.trim();
        if (code.length === 4) {
          joinByCode(code);
        }
      }
    });

    // Player slot clicks - left click to take over, right click to cycle AI mode
    playerSlots.forEach(slot => {
      slot.addEventListener('click', () => {
        cyclePlayerState(slot.dataset.slot);
      });
      slot.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        cycleAIMode(slot.dataset.slot);
      });
    });

    // Nick editing
    nickValueEl.textContent = Cabinet.data.nick;
    nickValueEl.addEventListener('click', () => {
      const newNick = prompt('Enter nickname:', Cabinet.data.nick);
      if (newNick) {
        Cabinet.setNick(newNick);
        nickValueEl.textContent = Cabinet.data.nick;
      }
    });

    // ========================================
    // AUTO-JOIN FROM URL
    // ========================================
    const pathMatch = location.pathname.match(/\/match\/([A-Z0-9]{4})\/?/i);
    if (pathMatch) {
      const code = pathMatch[1].toUpperCase();
      codeInput.value = code;
      setTimeout(() => joinByCode(code), 100);
    }

    // ========================================
    // BOOT SCREEN
    // ========================================
    function renderBootScreen() {
      const lines = [
        '╔══════════════════════════════════════════════════════╗',
        '║                                                      ║',
        '║   ██████╗  █████╗ ███╗   ███╗███╗   ███╗ █████╗     ║',
        '║  ██╔════╝ ██╔══██╗████╗ ████║████╗ ████║██╔══██╗    ║',
        '║  ██║  ███╗███████║██╔████╔██║██╔████╔██║███████║    ║',
        '║  ██║   ██║██╔══██║██║╚██╔╝██║██║╚██╔╝██║██╔══██║    ║',
        '║  ╚██████╔╝██║  ██║██║ ╚═╝ ██║██║ ╚═╝ ██║██║  ██║    ║',
        '║   ╚═════╝ ╚═╝  ╚═╝╚═╝     ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝    ║',
        '║                                                      ║',
        '║              A N S I   C A B I N E T                 ║',
        '║                                                      ║',
        '╠══════════════════════════════════════════════════════╣',
        '║                                                      ║',
        '║  Enter match code or wait for auto-connect...        ║',
        '║                                                      ║',
        '╚══════════════════════════════════════════════════════╝'
      ];
      gameDisplayEl.innerHTML = '<span style="color:#f0f">' + lines.join('\n') + '</span>';
    }

    // Show boot screen on load if no auto-join
    if (!pathMatch) {
      renderBootScreen();
    }
  </script>
</body>
</html>
