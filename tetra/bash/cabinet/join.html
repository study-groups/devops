<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ANSI Cabinet</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #888;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }

    /* Brutalist header */
    #header {
      width: 100%;
      max-width: 640px;
      background: #111;
      border: 2px solid #333;
      padding: 8px 12px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #header h1 {
      font-size: 14px;
      font-weight: normal;
      color: #666;
      letter-spacing: 2px;
    }
    #header h1 span { color: #0a0; }
    #game-name {
      font-size: 16px;
      color: #0ff;
      letter-spacing: 3px;
      font-weight: bold;
    }

    /* Hardware control panel */
    #control-panel {
      width: 100%;
      max-width: 640px;
      background: #0c0c0c;
      border: 2px solid #222;
      border-top: none;
      padding: 6px 10px;
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 8px;
    }
    .hw-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .hw-label {
      font-size: 9px;
      color: #444;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .hw-value {
      font-size: 12px;
      color: #0f0;
      font-family: 'Courier New', monospace;
    }
    .hw-value.warning { color: #f80; }
    .hw-value.critical { color: #f00; animation: blink 0.5s infinite; }

    /* Hardware buttons */
    .hw-btn {
      font-family: 'Courier New', monospace;
      font-size: 10px;
      padding: 4px 8px;
      background: #1a1a1a;
      color: #666;
      border: 1px solid #333;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .hw-btn:hover { background: #222; color: #aaa; border-color: #444; }
    .hw-btn:active { background: #333; }
    .hw-btn.danger { border-color: #600; color: #a00; }
    .hw-btn.danger:hover { background: #300; color: #f00; border-color: #800; }

    /* Reset button - big red */
    #reset-btn {
      width: 50px;
      height: 24px;
      background: #200;
      border: 2px solid #500;
      border-radius: 3px;
      color: #800;
      font-weight: bold;
      font-size: 9px;
      cursor: pointer;
    }
    #reset-btn:hover { background: #300; color: #c00; border-color: #700; }
    #reset-btn:active { background: #500; color: #fff; }

    /* Game display */
    #game-display {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.15;
      white-space: pre;
      background: #000;
      padding: 8px;
      border: 2px solid #222;
      min-width: 500px;
      min-height: 300px;
      color: #0f0;
    }

    /* Status bar */
    #status-bar {
      width: 100%;
      max-width: 640px;
      background: #0c0c0c;
      border: 2px solid #222;
      border-top: none;
      padding: 6px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
    }
    #slot-display { color: #0ff; }
    #players-display { color: #050; }

    /* Join controls */
    #join-panel {
      width: 100%;
      max-width: 640px;
      background: #111;
      border: 2px solid #333;
      border-top: none;
      padding: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    #join-panel input, #join-panel select {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      padding: 6px 10px;
      background: #0a0a0a;
      color: #0f0;
      border: 1px solid #333;
    }
    #join-panel input:focus, #join-panel select:focus {
      outline: none;
      border-color: #0a0;
    }
    #join-target { width: 180px; }
    #nick-input { width: 80px; }
    #slot-select { width: 90px; }

    #join-btn {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 6px 16px;
      background: #020;
      color: #0a0;
      border: 1px solid #0a0;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    #join-btn:hover { background: #030; color: #0f0; }

    #takeover-btn {
      font-family: 'Courier New', monospace;
      font-size: 10px;
      padding: 4px 8px;
      background: #200;
      color: #a00;
      border: 1px solid #500;
      cursor: pointer;
      text-transform: uppercase;
    }
    #takeover-btn:hover { background: #300; color: #f00; }
    #takeover-btn:disabled { opacity: 0.3; cursor: not-allowed; }

    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
  </style>
</head>
<body>
  <!-- Header -->
  <div id="header">
    <h1><span>ANSI</span> CABINET</h1>
    <div id="game-name">---</div>
  </div>

  <!-- Hardware control panel -->
  <div id="control-panel">
    <div class="hw-group">
      <span class="hw-label">TIME</span>
      <span class="hw-value" id="time-remaining">--:--</span>
    </div>
    <button class="hw-btn" id="extend-btn">+5M</button>
    <div style="flex:1"></div>
    <button id="reset-btn">RESET</button>
  </div>

  <!-- Game display -->
  <pre id="game-display">
    ╔═══════════════════════════════════════╗
    ║                                       ║
    ║         ANSI CABINET v1.0             ║
    ║                                       ║
    ║   Enter code or address to connect    ║
    ║                                       ║
    ╚═══════════════════════════════════════╝
  </pre>

  <!-- Status bar -->
  <div id="status-bar">
    <span id="slot-display">OFFLINE</span>
    <span id="players-display"></span>
  </div>

  <!-- Join panel -->
  <div id="join-panel">
    <input type="text" id="join-target" placeholder="CODE or ws://host:port" autocomplete="off">
    <select id="slot-select">
      <option value="">AUTO</option>
      <option value="p1">P1</option>
      <option value="p2">P2</option>
      <option value="p3">P3</option>
      <option value="p4">P4</option>
    </select>
    <button id="join-btn">Connect</button>
    <button id="takeover-btn" disabled>Takeover</button>
    <input type="text" id="nick-input" placeholder="Nick">
  </div>

  <script>
    // ========================================
    // CABINET IDENTITY
    // ========================================
    const Cabinet = {
      init() {
        let data = localStorage.getItem('cabinet');
        if (data) {
          this.data = JSON.parse(data);
          this.data.visits++;
          this.data.lastSeen = Date.now();
        } else {
          this.data = {
            cid: 'cab_' + Math.random().toString(36).substr(2, 6),
            nick: '',
            visits: 1,
            firstSeen: Date.now(),
            lastSeen: Date.now(),
            slots: []
          };
        }
        this.save();
        return this;
      },
      save() { localStorage.setItem('cabinet', JSON.stringify(this.data)); },
      setNick(nick) { this.data.nick = nick.substring(0, 12); this.save(); },
      recordSlot(slot) {
        if (!this.data.slots.includes(slot)) {
          this.data.slots.push(slot);
          this.save();
        }
      }
    }.init();

    // ========================================
    // CONTROLDECK BRIDGE (BroadcastChannel)
    // ========================================
    const ControlDeckBridge = {
      enabled: false,
      stateChannel: null,
      gameChannel: null,

      init(gameType) {
        if (!window.BroadcastChannel) {
          console.log('[bridge] BroadcastChannel not supported');
          return this;
        }
        this.stateChannel = new BroadcastChannel('controldeck-game-state');
        if (gameType) this.setGame(gameType);
        this.enabled = true;
        console.log('[bridge] ControlDeck bridge enabled');
        return this;
      },

      setGame(gameType) {
        if (this.gameChannel) this.gameChannel.close();
        const name = `controldeck-${gameType.toLowerCase()}-state`;
        this.gameChannel = new BroadcastChannel(name);
        console.log('[bridge] Game channel:', name);
      },

      broadcastState(state, gameName) {
        if (!this.enabled) return;
        const msg = { t: 'state', ts: Date.now(), game: gameName, state };
        if (this.stateChannel) this.stateChannel.postMessage(msg);
        if (this.gameChannel) this.gameChannel.postMessage(msg);
      }
    };

    // ========================================
    // GAMMA DETECTION
    // ========================================
    const Gamma = {
      url: null,
      available: false,
      async detect() {
        this.url = location.pathname.startsWith('/cabinet')
          ? location.origin
          : 'http://localhost:8085';
        try {
          const resp = await fetch(`${this.url}/api/status`, {
            method: 'GET',
            signal: AbortSignal.timeout(2000)
          });
          this.available = resp.ok;
        } catch (e) {
          this.available = false;
        }
        return this.available;
      }
    };

    // ========================================
    // ANSI PARSER
    // ========================================
    const ANSI = {
      colors: {
        30: '#000', 31: '#a00', 32: '#0a0', 33: '#a50',
        34: '#00a', 35: '#a0a', 36: '#0aa', 37: '#aaa',
        90: '#555', 91: '#f55', 92: '#5f5', 93: '#ff5',
        94: '#55f', 95: '#f5f', 96: '#5ff', 97: '#fff'
      },
      toHtml(text) {
        if (!text) return '';
        let html = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        html = html.replace(/\x1b\[([0-9;]+)m/g, (match, codes) => {
          const parts = codes.split(';');
          let style = [], close = false;
          for (const code of parts) {
            const n = parseInt(code);
            if (n === 0) close = true;
            else if (n === 1) style.push('font-weight:bold');
            else if ((n >= 30 && n <= 37) || (n >= 90 && n <= 97))
              style.push('color:' + (this.colors[n] || '#fff'));
            else if (n >= 40 && n <= 47)
              style.push('background:' + (this.colors[n - 10] || '#000'));
          }
          if (close) return '</span>';
          if (style.length) return '<span style="' + style.join(';') + '">';
          return '';
        });
        return html;
      }
    };

    // ========================================
    // STATE
    // ========================================
    let ws = null;
    let slot = null;
    let gameName = null;
    let matchCode = null;
    let matchExpires = null;
    let timerInterval = null;
    let wsUrl = null;

    const displayEl = document.getElementById('game-display');
    const gameNameEl = document.getElementById('game-name');
    const slotDisplayEl = document.getElementById('slot-display');
    const playersDisplayEl = document.getElementById('players-display');
    const timeRemainingEl = document.getElementById('time-remaining');
    const joinTargetEl = document.getElementById('join-target');
    const slotSelectEl = document.getElementById('slot-select');
    const nickInputEl = document.getElementById('nick-input');
    const joinBtn = document.getElementById('join-btn');
    const takeoverBtn = document.getElementById('takeover-btn');
    const resetBtn = document.getElementById('reset-btn');
    const extendBtn = document.getElementById('extend-btn');

    // ========================================
    // TIMER
    // ========================================
    function formatTime(ms) {
      if (ms <= 0) return '00:00';
      const secs = Math.floor(ms / 1000);
      const mins = Math.floor(secs / 60);
      return `${mins.toString().padStart(2, '0')}:${(secs % 60).toString().padStart(2, '0')}`;
    }

    function updateTimer() {
      if (!matchExpires) {
        timeRemainingEl.textContent = '--:--';
        timeRemainingEl.className = 'hw-value';
        return;
      }
      const remaining = matchExpires - Date.now();
      timeRemainingEl.textContent = formatTime(remaining);
      if (remaining <= 0) {
        timeRemainingEl.className = 'hw-value critical';
      } else if (remaining < 60000) {
        timeRemainingEl.className = 'hw-value critical';
      } else if (remaining < 180000) {
        timeRemainingEl.className = 'hw-value warning';
      } else {
        timeRemainingEl.className = 'hw-value';
      }
    }

    function startTimer(expires) {
      matchExpires = expires;
      updateTimer();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 1000);
    }

    function stopTimer() {
      matchExpires = null;
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = null;
      updateTimer();
    }

    // ========================================
    // CONTROLS
    // ========================================
    async function extendMatch() {
      if (!matchCode || !Gamma.available) return;
      try {
        const resp = await fetch(`${Gamma.url}/api/match/extend`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: matchCode })
        });
        const result = await resp.json();
        if (result.ok) {
          matchExpires = result.expires;
          updateTimer();
        }
      } catch (e) {
        console.error('[cabinet] Failed to extend:', e);
      }
    }

    function sendReset() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        // Send game reset command
        ws.send(JSON.stringify({ t: 'game.reset' }));
      }
    }

    function sendTakeover() {
      const requestSlot = slotSelectEl.value;
      if (!requestSlot || !ws || ws.readyState !== WebSocket.OPEN) return;

      // Re-identify with takeover request
      ws.send(JSON.stringify({
        t: 'identify',
        cid: Cabinet.data.cid,
        nick: Cabinet.data.nick || undefined,
        visits: Cabinet.data.visits,
        requestSlot: requestSlot,
        takeover: true
      }));
    }

    // ========================================
    // CONNECTION
    // ========================================
    function updateSlotDisplay() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        slotDisplayEl.textContent = 'OFFLINE';
        slotDisplayEl.style.color = '#666';
      } else if (slot) {
        const label = slot === 'spectator' ? 'SPECTATOR' : slot.toUpperCase();
        slotDisplayEl.textContent = label + (matchCode ? ` [${matchCode}]` : '');
        slotDisplayEl.style.color = slot === 'spectator' ? '#666' : '#0ff';
      }
    }

    function updatePlayersDisplay(players) {
      if (!players || players.length === 0) {
        playersDisplayEl.textContent = '';
        return;
      }
      playersDisplayEl.innerHTML = players.map(p => {
        const isMe = p.cid === Cabinet.data.cid;
        const color = isMe ? '#0ff' : '#050';
        const name = p.nick || p.cid?.substring(0, 6) || 'anon';
        return `<span style="color:${color}">${p.slot.toUpperCase()}:${name}</span>`;
      }).join(' ');
    }

    function updateGameName(name) {
      gameName = name;
      gameNameEl.textContent = name || '---';
      document.title = name ? `${name} | ANSI Cabinet` : 'ANSI Cabinet';
      // Update bridge with game type for game-specific channel
      if (name && ControlDeckBridge.enabled) {
        ControlDeckBridge.setGame(name);
      }
    }

    async function smartJoin() {
      const input = joinTargetEl.value.trim();
      if (!input) return;

      if (input.startsWith('ws://') || input.startsWith('wss://')) {
        wsUrl = input;
        connect();
      } else if (input.includes(':') && /:\d+$/.test(input)) {
        wsUrl = `ws://${input}`;
        connect();
      } else {
        await joinByCode(input.toUpperCase());
      }
    }

    async function joinByCode(code) {
      if (!Gamma.available) {
        slotDisplayEl.textContent = 'NO GAMMA';
        return;
      }

      matchCode = code;
      slotDisplayEl.textContent = 'RESOLVING...';

      try {
        const resp = await fetch(`${Gamma.url}/api/match/join`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code })
        });

        if (!resp.ok) {
          slotDisplayEl.textContent = 'NOT FOUND';
          return;
        }

        const data = await resp.json();
        if (data.host) {
          wsUrl = data.host.startsWith('ws://') ? data.host : `ws://${data.host}`;
          if (data.game) updateGameName(data.game.toUpperCase());

          // Get match expiration
          try {
            const matchResp = await fetch(`${Gamma.url}/api/match/${code}`);
            if (matchResp.ok) {
              const info = await matchResp.json();
              if (info.expires) startTimer(info.expires);
            }
          } catch (e) {}

          connect();
        }
      } catch (e) {
        slotDisplayEl.textContent = 'ERROR';
      }
    }

    function connect() {
      if (!wsUrl) return;
      if (ws) ws.close();

      slotDisplayEl.textContent = 'CONNECTING...';
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        const nickVal = nickInputEl.value.trim();
        if (nickVal) Cabinet.setNick(nickVal);

        const requestSlot = slotSelectEl.value;
        ws.send(JSON.stringify({
          t: 'identify',
          cid: Cabinet.data.cid,
          nick: Cabinet.data.nick || undefined,
          visits: Cabinet.data.visits,
          requestSlot: requestSlot,
          takeover: ['p1', 'p2', 'p3', 'p4'].includes(requestSlot)
        }));
      };

      ws.onmessage = (e) => {
        try {
          handleMessage(JSON.parse(e.data));
        } catch (err) {}
      };

      ws.onclose = () => {
        slot = null;
        updateSlotDisplay();
        updatePlayersDisplay([]);
        stopTimer();
        takeoverBtn.disabled = true;
      };

      ws.onerror = () => {
        slotDisplayEl.textContent = 'ERROR';
      };
    }

    function handleMessage(data) {
      if (data.t === 'welcome') {
        slot = data.slot;
        Cabinet.recordSlot(slot);
        updateSlotDisplay();
        if (data.game) updateGameName(data.game.toUpperCase());
        if (data.players) updatePlayersDisplay(data.players);
        // Enable takeover if we're spectator or want to switch
        takeoverBtn.disabled = false;
      } else if (data.t === 'players') {
        updatePlayersDisplay(data.players || []);
      } else if (data.t === 'takeover') {
        if (data.oldCid === Cabinet.data.cid) {
          slot = 'spectator';
          updateSlotDisplay();
        }
      } else if (data.t === 'frame') {
        displayEl.innerHTML = ANSI.toHtml(data.display || '');
        if (data.game && !gameName) updateGameName(data.game.toUpperCase());
        // Bridge: broadcast state to ControlDeck
        if (data.state && ControlDeckBridge.enabled) {
          ControlDeckBridge.broadcastState(data.state, gameName);
        }
      }
    }

    // ========================================
    // INPUT
    // ========================================
    function sendInput(msg) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(msg));
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
        e.preventDefault();
      }
      // Send both e.key and e.code for compatibility with different games
      sendInput({ t: 'input', src: 'keyboard', key: e.key, ctrl: e.code, val: 1, pressed: true });
    });

    document.addEventListener('keyup', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      sendInput({ t: 'input', src: 'keyboard', key: e.key, ctrl: e.code, val: 0, pressed: false });
    });

    // Gamepad
    let gamepadPollId = null;
    const lastGamepadState = {};

    function pollGamepads() {
      const gamepads = navigator.getGamepads();
      for (const gp of gamepads) {
        if (!gp) continue;
        const last = lastGamepadState[gp.index] || { axes: [], buttons: [] };

        for (let i = 0; i < gp.axes.length; i++) {
          const val = gp.axes[i];
          if (Math.abs(val - (last.axes[i] || 0)) > 0.01) {
            const ctrl = ['left-x', 'left-y', 'right-x', 'right-y'][i] || `axis-${i}`;
            sendInput({ t: 'input', src: 'gamepad', ctrl, val });
          }
          last.axes[i] = val;
        }

        for (let i = 0; i < gp.buttons.length; i++) {
          const btn = gp.buttons[i];
          const wasPressed = last.buttons[i] || false;
          if (btn.pressed !== wasPressed) {
            const ctrl = ['a', 'b', 'x', 'y', 'l1', 'r1', 'l2', 'r2',
              'select', 'start', 'l3', 'r3',
              'dpad-up', 'dpad-down', 'dpad-left', 'dpad-right', 'home'][i] || `button-${i}`;
            sendInput({ t: 'input', src: 'gamepad', ctrl, val: btn.pressed ? 1 : 0, pressed: btn.pressed });
          }
          last.buttons[i] = btn.pressed;
        }
        lastGamepadState[gp.index] = last;
      }
      gamepadPollId = requestAnimationFrame(pollGamepads);
    }

    window.addEventListener('gamepadconnected', () => {
      if (!gamepadPollId) pollGamepads();
    });

    // ========================================
    // EVENT BINDINGS
    // ========================================
    joinBtn.addEventListener('click', smartJoin);
    joinTargetEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') smartJoin(); });
    resetBtn.addEventListener('click', sendReset);
    extendBtn.addEventListener('click', extendMatch);
    takeoverBtn.addEventListener('click', sendTakeover);

    slotSelectEl.addEventListener('change', () => {
      const val = slotSelectEl.value;
      takeoverBtn.disabled = !val || !ws || ws.readyState !== WebSocket.OPEN;
    });

    // ========================================
    // INIT
    // ========================================
    async function init() {
      // Initialize ControlDeck bridge for AI integration
      ControlDeckBridge.init();

      await Gamma.detect();

      if (Cabinet.data.nick) {
        nickInputEl.value = Cabinet.data.nick;
      }

      const params = new URLSearchParams(location.search);
      if (params.has('host')) {
        const host = params.get('host');
        joinTargetEl.value = host;
        wsUrl = host.startsWith('ws://') ? host : `ws://${host}`;
        setTimeout(connect, 100);
      } else if (params.has('code')) {
        const code = params.get('code');
        joinTargetEl.value = code;
        setTimeout(() => joinByCode(code.toUpperCase()), 100);
      } else if (location.hostname && location.port) {
        // Auto-detect: we're being served from a game server
        // Pre-populate and auto-connect to the same host:port
        const autoUrl = `ws://${location.host}`;
        joinTargetEl.value = location.host;
        wsUrl = autoUrl;
        setTimeout(connect, 100);
      }
    }

    init();
  </script>
</body>
</html>
