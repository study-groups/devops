<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Join Game</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: monospace;
      background: #1a1a1a;
      color: #0f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin-bottom: 10px; color: #0ff; }
    #status {
      padding: 10px 20px;
      margin-bottom: 20px;
      border-radius: 4px;
      background: #333;
    }
    #status.connected { background: #0a3; color: #fff; }
    #status.error { background: #a00; color: #fff; }
    #status.warning { background: #a50; color: #fff; }
    #game-display {
      font-family: monospace;
      font-size: 14px;
      line-height: 1.2;
      white-space: pre;
      background: #000;
      padding: 10px;
      border: 2px solid #333;
      min-width: 500px;
      min-height: 300px;
    }
    #controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    input, button, select {
      font-family: monospace;
      font-size: 14px;
      padding: 8px 16px;
      border: 1px solid #0f0;
      background: #000;
      color: #0f0;
    }
    button:hover { background: #0f0; color: #000; cursor: pointer; }
    #join-target {
      width: 220px;
      text-align: center;
      letter-spacing: 1px;
    }
    #join-target::placeholder { letter-spacing: normal; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
  </style>
</head>
<body>
  <h1 id="game-title">Join Game</h1>
  <div id="status">Enter code or address</div>
  <div id="match-timer" style="display:none;padding:5px 10px;background:#111;border:1px solid #030;font-size:12px;margin-bottom:10px;">
    <span style="color:#050">Match expires in:</span> <span id="time-remaining">--:--</span>
    <button id="extend-btn" style="margin-left:10px;background:#000;border:1px solid #0f0;color:#0f0;padding:2px 8px;cursor:pointer;font-family:monospace;">+5m</button>
  </div>
  <pre id="game-display">Waiting for connection...</pre>
  <div id="players-display" style="padding:5px 10px;margin-bottom:10px;background:#111;border:1px solid #030;font-size:12px;">
    <span style="color:#050">No players connected</span>
  </div>
  <div id="controls">
    <input type="text" id="join-target" placeholder="CODE or ws://host:port" autocomplete="off">
    <button id="join-btn">Join</button>
    <select id="slot-select" style="padding:6px;">
      <option value="">Auto</option>
      <option value="p1">P1</option>
      <option value="p2">P2</option>
      <option value="p3">P3</option>
      <option value="p4">P4</option>
      <option value="share">Share</option>
    </select>
    <input type="text" id="nick-input" placeholder="Nick" style="width:80px" />
  </div>

  <script>
    // ========================================
    // CABINET IDENTITY (loose, dev-friendly)
    // ========================================
    const Cabinet = {
      init() {
        let data = localStorage.getItem('cabinet');
        if (data) {
          this.data = JSON.parse(data);
          this.data.visits++;
          this.data.lastSeen = Date.now();
        } else {
          this.data = {
            cid: 'cab_' + Math.random().toString(36).substr(2, 6),
            nick: '',
            visits: 1,
            firstSeen: Date.now(),
            lastSeen: Date.now(),
            slots: []
          };
        }
        this.save();
        console.log('[cabinet] Identity:', this.data.cid);
        return this;
      },
      save() {
        localStorage.setItem('cabinet', JSON.stringify(this.data));
      },
      setNick(nick) {
        this.data.nick = nick.substring(0, 12);
        this.save();
      },
      recordSlot(slot) {
        if (!this.data.slots.includes(slot)) {
          this.data.slots.push(slot);
          this.save();
        }
      },
      dump() { return this.data; }
    }.init();

    window.Cabinet = Cabinet;

    // ========================================
    // GAMMA DETECTION
    // ========================================
    const Gamma = {
      // Detect GAMMA URL based on how we're served
      url: null,
      available: false,

      async detect() {
        // If served from gamma-web, use same origin
        if (location.pathname.startsWith('/cabinet')) {
          this.url = location.origin;
        } else {
          // Standalone - try localhost:8085
          this.url = 'http://localhost:8085';
        }

        // Check if GAMMA is responding
        try {
          const resp = await fetch(`${this.url}/api/status`, {
            method: 'GET',
            signal: AbortSignal.timeout(2000)
          });
          if (resp.ok) {
            this.available = true;
            console.log('[gamma] Available at', this.url);
          }
        } catch (e) {
          this.available = false;
          console.log('[gamma] Not available at', this.url);
        }
        return this.available;
      }
    };

    // ANSI to HTML converter (xterm-style)
    const ANSI = {
      colors: {
        30: '#000', 31: '#a00', 32: '#0a0', 33: '#a50',
        34: '#00a', 35: '#a0a', 36: '#0aa', 37: '#aaa',
        90: '#555', 91: '#f55', 92: '#5f5', 93: '#ff5',
        94: '#55f', 95: '#f5f', 96: '#5ff', 97: '#fff'
      },
      toHtml(text) {
        if (!text) return '';
        // Escape HTML first
        let html = text
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');

        // Parse ANSI codes: \x1b[...m
        html = html.replace(/\x1b\[([0-9;]+)m/g, (match, codes) => {
          const parts = codes.split(';');
          let style = [];
          let close = false;

          for (const code of parts) {
            const n = parseInt(code);
            if (n === 0) {
              close = true;  // Reset
            } else if (n === 1) {
              style.push('font-weight:bold');
            } else if (n >= 30 && n <= 37 || n >= 90 && n <= 97) {
              style.push('color:' + (this.colors[n] || '#fff'));
            } else if (n >= 40 && n <= 47) {
              style.push('background:' + (this.colors[n - 10] || '#000'));
            }
          }

          if (close) return '</span>';
          if (style.length) return '<span style="' + style.join(';') + '">';
          return '';
        });

        return html;
      }
    };

    // Unified input format
    function createInput(src, ctrl, val, pressed = null) {
      const msg = { t: 'input', src, ctrl, val };
      if (pressed !== null) msg.pressed = pressed;
      return msg;
    }

    // WebSocket connection
    let ws = null;
    let slot = null;
    let gameName = null;  // Current game name
    let players = [];  // Track connected players
    let matchCode = null;  // Current match code
    let matchExpires = null;  // Match expiration timestamp
    let timerInterval = null;  // Timer update interval
    let wsUrl = null;  // Current WebSocket URL

    const statusEl = document.getElementById('status');
    const displayEl = document.getElementById('game-display');
    const titleEl = document.getElementById('game-title');
    const joinTargetEl = document.getElementById('join-target');
    const joinBtn = document.getElementById('join-btn');
    const matchTimerEl = document.getElementById('match-timer');
    const timeRemainingEl = document.getElementById('time-remaining');
    const extendBtn = document.getElementById('extend-btn');

    // Match timer functions
    function formatTimeRemaining(ms) {
      if (ms <= 0) return 'EXPIRED';
      const secs = Math.floor(ms / 1000);
      const mins = Math.floor(secs / 60);
      const remainingSecs = secs % 60;
      return `${mins}:${remainingSecs.toString().padStart(2, '0')}`;
    }

    function updateMatchTimer() {
      if (!matchExpires) return;
      const remaining = matchExpires - Date.now();
      timeRemainingEl.textContent = formatTimeRemaining(remaining);

      // Visual warning states
      if (remaining <= 0) {
        timeRemainingEl.style.color = '#f00';
        timeRemainingEl.style.animation = 'none';
        updateStatus('Match expired!', 'error');
      } else if (remaining < 30000) {
        timeRemainingEl.style.color = '#f00';
        timeRemainingEl.style.animation = 'pulse 0.5s infinite';
      } else if (remaining < 60000) {
        timeRemainingEl.style.color = '#f80';
        timeRemainingEl.style.animation = 'none';
      } else {
        timeRemainingEl.style.color = '#0f0';
        timeRemainingEl.style.animation = 'none';
      }
    }

    function startMatchTimer(expires) {
      matchExpires = expires;
      matchTimerEl.style.display = 'block';
      updateMatchTimer();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateMatchTimer, 1000);
    }

    function stopMatchTimer() {
      matchExpires = null;
      matchCode = null;
      matchTimerEl.style.display = 'none';
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    async function extendMatch() {
      if (!matchCode || !Gamma.available) return;
      try {
        const resp = await fetch(`${Gamma.url}/api/match/extend`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code: matchCode })
        });
        const result = await resp.json();
        if (result.ok) {
          matchExpires = result.expires;
          updateMatchTimer();
          console.log(`[cabinet] Extended match ${matchCode} by 5 minutes`);
        }
      } catch (e) {
        console.error('[cabinet] Failed to extend match:', e);
      }
    }

    extendBtn.addEventListener('click', extendMatch);

    function updateStatus(text, className = '') {
      statusEl.textContent = text;
      statusEl.className = className;
    }

    function updateTitle(name) {
      gameName = name;
      titleEl.textContent = name || 'Join Game';
      document.title = name ? `${name} - Cabinet` : 'Join Game';
    }

    // Smart join - detect if input is code or ws:// URL
    async function smartJoin() {
      const input = joinTargetEl.value.trim();
      if (!input) {
        updateStatus('Enter a code or ws://host:port', 'error');
        return;
      }

      // Direct WebSocket URL
      if (input.startsWith('ws://') || input.startsWith('wss://')) {
        wsUrl = input;
        connect();
        return;
      }

      // Looks like host:port without ws://
      if (input.includes(':') && /:\d+$/.test(input)) {
        wsUrl = `ws://${input}`;
        connect();
        return;
      }

      // Assume it's a GAMMA code
      const code = input.toUpperCase();
      if (code.length < 3 || code.length > 6) {
        updateStatus('Invalid code format', 'error');
        return;
      }

      await joinByCode(code);
    }

    // Join game by code via GAMMA API
    async function joinByCode(code) {
      if (!Gamma.available) {
        updateStatus('GAMMA not available - use ws://host:port', 'warning');
        return;
      }

      updateStatus('Resolving code...');
      matchCode = code;

      try {
        const resp = await fetch(`${Gamma.url}/api/match/join`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ code })
        });

        if (!resp.ok) {
          const err = await resp.json().catch(() => ({ error: resp.statusText }));
          updateStatus(`Join failed: ${err.error || 'Unknown error'}`, 'error');
          return;
        }

        const data = await resp.json();

        if (data.host) {
          wsUrl = data.host.startsWith('ws://') ? data.host : `ws://${data.host}`;

          // Update title with game name
          if (data.game) {
            updateTitle(data.game.toUpperCase());
          }

          // Fetch match info for expiration timer
          try {
            const matchResp = await fetch(`${Gamma.url}/api/match/${code}`);
            if (matchResp.ok) {
              const matchInfo = await matchResp.json();
              if (matchInfo.expires) startMatchTimer(matchInfo.expires);
              if (matchInfo.game) updateTitle(matchInfo.game.toUpperCase());
            }
          } catch (e) {
            console.log('[join] Could not fetch match info');
          }

          if (data.full) {
            updateStatus('Match full - connecting as spectator...');
            document.getElementById('slot-select').value = 'share';
          } else {
            updateStatus('Connecting...');
          }
          connect();
        } else {
          updateStatus('No host found for this code', 'error');
        }
      } catch (e) {
        console.error('[join] Error:', e);
        updateStatus(`Connection error: ${e.message}`, 'error');
      }
    }

    function connect() {
      if (!wsUrl) {
        updateStatus('No address specified', 'error');
        return;
      }

      if (ws) {
        ws.close();
      }

      updateStatus('Connecting...');
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        console.log('[join] Connected to', wsUrl);

        // Update nick from input if set
        const nickInput = document.getElementById('nick-input');
        if (nickInput && nickInput.value) {
          Cabinet.setNick(nickInput.value);
        }

        // Get slot preference
        const slotPref = document.getElementById('slot-select')?.value || '';

        // Send identity with slot preference
        ws.send(JSON.stringify({
          t: 'identify',
          cid: Cabinet.data.cid,
          nick: Cabinet.data.nick || undefined,
          visits: Cabinet.data.visits,
          requestSlot: slotPref,
          takeover: ['p1', 'p2', 'p3', 'p4'].includes(slotPref)
        }));
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleMessage(data);
        } catch (e) {
          console.error('[join] Parse error:', e);
        }
      };

      ws.onclose = () => {
        updateStatus('Disconnected');
        updatePlayersDisplay([]);
        stopMatchTimer();
        ws = null;
      };

      ws.onerror = (err) => {
        updateStatus('Connection error', 'error');
        console.error('[join] WebSocket error:', err);
      };
    }

    function updatePlayersDisplay(playerList) {
      players = playerList;
      const el = document.getElementById('players-display');
      if (!el) return;

      if (playerList.length === 0) {
        el.innerHTML = '<span style="color:#050">No players connected</span>';
        return;
      }

      el.innerHTML = playerList.map(p => {
        const isMe = p.cid === Cabinet.data.cid;
        const color = isMe ? '#0ff' : '#0f0';
        const marker = isMe ? ' (you)' : '';
        return `<span style="color:${color}">${p.slot.toUpperCase()}: ${p.nick || p.cid || 'anon'}${marker}</span>`;
      }).join(' | ');
    }

    function handleMessage(data) {
      if (data.t === 'welcome') {
        slot = data.slot;
        Cabinet.recordSlot(slot);

        // Update status with slot only (no confusing playerId)
        const slotLabel = slot === 'spectator' ? 'SPECTATOR' : slot.toUpperCase();
        const codeStr = matchCode ? ` [${matchCode}]` : '';
        updateStatus(`Connected as ${slotLabel}${codeStr}`, 'connected');

        // Update title if game name provided
        if (data.game) {
          updateTitle(data.game.toUpperCase());
        }

        if (data.players) updatePlayersDisplay(data.players);
      } else if (data.t === 'players') {
        updatePlayersDisplay(data.players || []);
      } else if (data.t === 'takeover') {
        if (data.oldCid === Cabinet.data.cid) {
          updateStatus(`Moved to SPECTATOR`, 'warning');
          slot = 'spectator';
        }
      } else if (data.t === 'frame') {
        displayEl.innerHTML = ANSI.toHtml(data.display || '');
        // Update title from frame if provided
        if (data.game && !gameName) {
          updateTitle(data.game.toUpperCase());
        }
      }
    }

    function sendInput(input) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(input));
      }
    }

    // Keyboard input
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT') return;

      // Prevent default for game keys
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
        e.preventDefault();
      }

      const input = createInput('keyboard', e.code, 1, true);
      sendInput(input);
    });

    document.addEventListener('keyup', (e) => {
      if (e.target.tagName === 'INPUT') return;

      const input = createInput('keyboard', e.code, 0, false);
      sendInput(input);
    });

    // Gamepad polling
    let gamepadPollId = null;
    const lastGamepadState = {};

    function pollGamepads() {
      const gamepads = navigator.getGamepads();

      for (const gp of gamepads) {
        if (!gp) continue;

        const last = lastGamepadState[gp.index] || { axes: [], buttons: [] };

        // Check axes
        for (let i = 0; i < gp.axes.length; i++) {
          const val = gp.axes[i];
          if (Math.abs(val - (last.axes[i] || 0)) > 0.01) {
            const ctrl = ['left-x', 'left-y', 'right-x', 'right-y'][i] || `axis-${i}`;
            sendInput(createInput('gamepad', ctrl, val));
          }
          last.axes[i] = val;
        }

        // Check buttons
        for (let i = 0; i < gp.buttons.length; i++) {
          const btn = gp.buttons[i];
          const wasPressed = last.buttons[i] || false;

          if (btn.pressed !== wasPressed) {
            const ctrl = [
              'a', 'b', 'x', 'y', 'l1', 'r1', 'l2', 'r2',
              'select', 'start', 'l3', 'r3',
              'dpad-up', 'dpad-down', 'dpad-left', 'dpad-right', 'home'
            ][i] || `button-${i}`;

            sendInput(createInput('gamepad', ctrl, btn.pressed ? 1 : 0, btn.pressed));
          }
          last.buttons[i] = btn.pressed;
        }

        lastGamepadState[gp.index] = last;
      }

      gamepadPollId = requestAnimationFrame(pollGamepads);
    }

    // Start gamepad polling when connected
    window.addEventListener('gamepadconnected', (e) => {
      console.log('[join] Gamepad connected:', e.gamepad.id);
      if (!gamepadPollId) {
        pollGamepads();
      }
    });

    window.addEventListener('gamepaddisconnected', (e) => {
      console.log('[join] Gamepad disconnected:', e.gamepad.id);
    });

    // Join button
    joinBtn.addEventListener('click', smartJoin);

    // Enter key handler
    joinTargetEl.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') smartJoin();
    });

    // Initialize
    async function init() {
      // Detect GAMMA availability
      await Gamma.detect();

      // Restore nickname if saved
      const nickInput = document.getElementById('nick-input');
      if (Cabinet.data.nick && nickInput) {
        nickInput.value = Cabinet.data.nick;
      }

      // Auto-connect if URL has ?host= or ?code= parameter
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('host')) {
        const host = urlParams.get('host');
        joinTargetEl.value = host;
        wsUrl = host.startsWith('ws://') ? host : `ws://${host}`;
        setTimeout(connect, 100);
      } else if (urlParams.has('code')) {
        const code = urlParams.get('code');
        joinTargetEl.value = code;
        setTimeout(() => joinByCode(code.toUpperCase()), 100);
      } else if (!Gamma.available) {
        updateStatus('Enter ws://host:port to connect', 'warning');
      }
    }

    init();
  </script>
</body>
</html>
