# PData: Plan 9-Inspired File Management System

## Overview

**PData** is a secure, token-based file management system inspired by Plan 9's namespace and authentication architecture. It implements a three-tier mounting system with JWT-based capabilities, providing unified access to distributed file resources through virtual mount points.

## Architectural Philosophy

PData follows **Plan 9's namespace principles** with modern security patterns:

1. **Namespace Abstraction**: Virtual mount points (`~data`, `~system`, `~/data/*`) map to physical paths
2. **Token-Based Capabilities**: JWT tokens contain user identity, roles, and mount configurations
3. **Unified Interface**: All file operations work through consistent mount abstractions
4. **Role-Based Security**: Fine-grained permissions through capability expressions

## Core Architecture

### The Orchestration Layer: `PData`

The main `PData` class serves as an orchestration layer that coordinates between specialized managers. It implements the **Facade pattern**, providing a simplified interface while delegating complex operations to focused subsystems:

```javascript
class PData {
    constructor(config) {
        this._validateConfig();      // Environment validation
        this._initializePaths();     // Directory structure setup  
        this._initializeManagers();  // Subsystem coordination
    }
}
```

The orchestrator maintains backward compatibility while internally distributing responsibilities to:

### Authentication Subsystem: `AuthSrv`

The `AuthSrv` manages token creation, validation, and path resolution:

- **JWT Tokens**: Signed tokens containing user identity, roles, capabilities, and mounts
- **Path Resolution**: Virtual mount point resolution (`~data`, `~system`, `~/data/users/alice`)
- **Capability Checking**: Fine-grained permission validation using minimatch patterns
- **Token Validation**: Secure token verification with expiration and signature checks

### User Management: `UserManager` & `CapabilityManager`

- **CSV Configuration**: Plan 9-style semicolon-separated capability lists
- **Password Security**: PBKDF2-SHA512 hashing with per-user salts  
- **Role Expansion**: Dynamic capability expansion from role definitions
- **Home Directories**: Optional `home_dir` field for custom user paths

```csv
# roles.csv (Plan 9 style)
user,cap:data:userspace;cap:home:basic
admin,cap:system:admin
```

### File Operations: `FileManager`

All file operations use token-based authorization with mount-aware path resolution:

- **Token Validation**: Every operation validates JWT token and extracts user capabilities
- **Mount Resolution**: Virtual paths (`~data/docs`) resolve to physical paths via token mounts
- **Capability Checks**: Operations validated against capability expressions (e.g., `read:~data/**`)
- **Symlink Support**: Safe symlink traversal with permission inheritance

### Mount Management: `MountManager`

Implements Plan 9-inspired three-tier mounting:

#### Three-Tier Mount Structure

**Regular Users:**
- `~data` → `$PD_DIR/data` (general userspace)
- `~/data/{type}/{user}` → User-specific home (e.g., `~/data/users/alice`, `~/data/projects/webapp`)

**Admin Users:**
- `~data` → `$PD_DIR/data` (userspace access)
- `~log` → `$PD_DIR/logs` (system logs)
- `~cache` → `$PD_DIR/cache` (system cache)
- `~uploads` → `$PD_DIR/uploads` (file uploads)
- `~system` → `$PD_DIR` (full system access)

## Directory Structure

PData implements a three-tier directory structure supporting diverse use cases:

```
$PD_DIR/                    # System root (~system for admins)
├── data/                   # Userspace root (~data)
│   ├── users/             # User home directories
│   │   └── <username>/    # ~/data/users/<username>
│   ├── projects/          # Project workspaces  
│   │   └── <project>/     # ~/data/projects/<project>
│   ├── games/             # Gaming environments
│   │   └── <game>/        # ~/data/games/<game>
│   └── shared/            # Shared resources
├── uploads/               # File staging (~uploads)
├── logs/                  # System logs (~log, admin only)
├── cache/                 # System cache (~cache, admin only)
├── users.csv              # User credentials + home_dir
├── roles.csv              # Role → capability mappings
├── capabilities.csv       # Capability definitions
└── assets.csv             # Asset set definitions
```

## Token-Based Capabilities

### Capability System

PData uses **Plan 9-inspired capability expressions** for fine-grained access control:

```javascript
// Capability format: operation:path_pattern
"read:~data/**"              // Read access to all userspace
"write:~/data/users/alice/**" // Write access to Alice's home
"list:~log/**"               // List system logs (admin only)
```

### Role Definitions (Plan 9 Style)

```csv
# roles.csv - semicolon-separated capabilities
user,cap:data:userspace;cap:home:basic
admin,cap:system:admin
dev,cap:data:userspace;cap:home:basic;cap:projects:access
```

### Token Structure

JWT tokens contain all necessary authorization data:

```javascript
{
  user: "alice",
  roles: ["user"],
  caps: ["read:~data/**", "write:~/data/users/alice/**"],
  mounts: {
    "~data": "/path/to/data",
    "~/data/users/alice": "/path/to/data/users/alice"
  }
}
```

## API Reference

### Core Methods

PData provides both legacy username-based and modern token-based APIs:

| Method | Parameters | Description | Returns |
|--------|------------|-------------|---------|
| **Authentication** | | | |
| `createToken(username, password)` | `username, password` | Authenticate user and create JWT token | `string` (JWT) or `null` |
| `validateToken(token)` | `token` | Validate JWT and extract user data | `object` or `null` |
| `validateUser(username, password)` | `username, password` | Legacy password validation | `boolean` |
| **File Operations (Token-based)** | | | |
| `listDirectory(token, path)` | `token_object, relative_path` | List directory contents via token | `{dirs: [], files: [], exists: boolean}` |
| `readFile(token, path)` | `token_object, relative_path` | Read file contents via token | `string` or `Error` |
| `writeFile(token, path, content)` | `token_object, relative_path, content` | Write file via token | `boolean` or `Error` |
| `deleteFile(token, path)` | `token_object, relative_path` | Delete file via token | `boolean` or `Error` |
| **File Operations (Legacy)** | | | |
| `listDirectory(username, path)` | `username, relative_path` | List directory contents | `{dirs: [], files: [], exists: boolean}` |
| `readFile(username, path)` | `username, relative_path` | Read file contents | `string` or `Error` |
| `writeFile(username, path, content)` | `username, relative_path, content` | Write file | `boolean` or `Error` |
| `deleteFile(username, path)` | `username, relative_path` | Delete file | `boolean` or `Error` |
| **User Management** | | | |
| `getUserRoles(username)` | `username` | Get user's assigned roles | `string[]` |
| `userExists(username)` | `username` | Check if user exists | `boolean` |

### Token-Based Operation Pattern

Modern PData operations use tokens for enhanced security:

```javascript
// 1. Authenticate and get token
const token = await pdata.createToken('alice', 'password');
const tokenObj = pdata.validateToken(token);

// 2. Perform operations with token
const files = await pdata.listDirectory(tokenObj, '');
const content = await pdata.readFile(tokenObj, 'document.md');
await pdata.writeFile(tokenObj, 'new-file.txt', 'content');
```

### Mount Point Reference

Virtual mount points provide Plan 9-style namespace abstraction:

| Mount Point | Admin Access | User Access | Physical Path | Description |
|-------------|--------------|-------------|---------------|-------------|
| `~data` | ✅ | ✅ | `$PD_DIR/data` | General userspace |
| `~system` | ✅ | ❌ | `$PD_DIR` | System root access |
| `~log` | ✅ | ❌ | `$PD_DIR/logs` | System logs |
| `~cache` | ✅ | ❌ | `$PD_DIR/cache` | System cache |
| `~uploads` | ✅ | ❌ | `$PD_DIR/uploads` | File staging |
| `~/data/users/{user}` | ✅ | ✅ (own) | `$PD_DIR/data/users/{user}` | User home directories |
| `~/data/projects/{proj}` | ✅ | ✅ (assigned) | `$PD_DIR/data/projects/{proj}` | Project workspaces |
| `~/data/games/{game}` | ✅ | ✅ (assigned) | `$PD_DIR/data/games/{game}` | Gaming environments |

### Path Resolution Examples

```javascript
// User 'alice' with home_dir='users/alice'
"" → "~/data/users/alice/"           // Root access via user mount
"docs/" → "~/data/users/alice/docs/" // Relative path via user mount  
"~data/shared/" → "~data/shared/"    // Explicit mount reference

// Admin user
"" → "~data/"                        // Root access via general mount
"~system/config/" → "~system/config/" // System access
"~log/errors.log" → "~log/errors.log" // Log access
```

## Configuration

### Environment Variables

PData requires specific environment configuration:

```bash
PD_DIR=/absolute/path/to/data/root     # Required: Data root directory
```

### CSV Configuration Files

PData uses Plan 9-style CSV configuration:

**users.csv:**
```csv
username,salt,hash,home_dir
alice,abc123,def456,users/alice
bob,ghi789,jkl012,projects/webapp
charlie,mno345,pqr678,games/rpg
```

**roles.csv:**
```csv
# Role → semicolon-separated capabilities
user,cap:data:userspace;cap:home:basic
admin,cap:system:admin
dev,cap:data:userspace;cap:home:basic;cap:projects:access
```

**capabilities.csv:**
```csv
cap:data:userspace,list:~data/**;read:~data/**;write:~data/**,Userspace access
cap:home:basic,list:~/data/{user}/**;read:~/data/{user}/**;write:~/data/{user}/**,Basic home access
cap:system:admin,list:~system/**;read:~system/**;write:~system/**,System administration
```

## Advanced Features

### Symlink Security

PData supports symlinks with capability-based permission checking:

- **Target Resolution**: Symlinks resolved through mount points
- **Permission Inheritance**: Operations on symlinks validated against target capabilities
- **Cross-User Protection**: Symlink access controlled by destination mount permissions

### Token Security

JWT tokens provide stateless authentication with built-in capabilities:

- **Signed Tokens**: HMAC-SHA256 signed with server secret
- **Expiration**: Configurable token lifetime (default: 1 hour)
- **Capability Embedding**: Tokens contain all necessary authorization data
- **Stateless Validation**: No server-side session storage required

## Testing and Validation

PData includes comprehensive test coverage:

- **Token-based Operations**: JWT creation, validation, and capability checking
- **Mount Resolution**: Virtual path resolution through three-tier mounting
- **Permission Boundaries**: Cross-user access controls and admin privileges
- **File Operations**: CRUD operations with proper authorization
- **Symlink Handling**: Safe symlink traversal with permission validation

### Test Coverage

```bash
npm test                    # Run full test suite
npm test capability.test.js # Test token and capability system
npm test api.test.js        # Test API endpoints
npm test symlink.test.js    # Test symlink security
```

## Migration from Legacy

Existing username-based code can migrate incrementally:

```javascript
// Legacy pattern
await pdata.readFile(username, 'document.txt');

// Modern token-based pattern  
const token = await pdata.createToken(username, password);
const tokenObj = pdata.validateToken(token);
await pdata.readFile(tokenObj, 'document.txt');
```

## Conclusion

PData implements a **Plan 9-inspired namespace and capability system** for modern Node.js applications. Through its three-tier mounting architecture, token-based capabilities, and Plan 9-style configuration, it provides:

- **Security**: Fine-grained capability-based access control
- **Scalability**: Stateless JWT tokens with embedded authorization
- **Flexibility**: Support for diverse user types (users, projects, games)
- **Simplicity**: Plan 9's elegant text-based configuration philosophy

This architecture makes PData suitable for applications requiring secure, multi-tenant file operations with sophisticated permission models.