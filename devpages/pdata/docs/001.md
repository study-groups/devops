I'll analyze the current PData system and discuss your proposed improvements. Let me first examine the current implementation to understand the role system and data structure.
Read file: pdata/PData.js
Read file: server/routes/auth.js
Read file: pdata/utils/PathManager.js

Read file: server/middleware/auth.js

Read file: server/middleware/auth.js

Perfect! Now I have a complete understanding of your current PData system. Let me provide a comprehensive analysis and improvement plan for both areas you mentioned.

## **Current PData System Analysis**

Your current system has these strengths:
- **Multiple roles per user**: Already supports arrays like `['admin', 'user', 'dev']`
- **Basic API token system**: Working token generation/validation
- **Path-based permissions**: Admin vs user directory scoping
- **CSV-based storage**: Simple, readable, version-controllable

### **Current Limitations:**
1. **Role checking only uses first role** (`getUserRole()` returns `roles[0]`)
2. **Binary permissions**: Admin gets everything, users get limited scope
3. **No granular permissions**: Can't grant specific access to files/directories
4. **Tokens have no permissions context**: Tokens inherit full user permissions

---

## **1. Tag-Based Role System Proposal**

### **Enhanced Role Architecture**
```javascript
// Instead of: ['admin', 'user']
// Use: ['admin', 'dev', 'game-zelda', 'project-website', 'share-readonly']

// New role categories:
const ROLE_TYPES = {
    SYSTEM: ['admin', 'user', 'guest'],           // System-level access
    FUNCTIONAL: ['dev', 'editor', 'viewer'],      // Functional capabilities  
    CONTEXT: ['game-*', 'project-*'],             // Context-specific access
    PERMISSION: ['read-*', 'write-*', 'delete-*'] // Granular permissions
};
```

### **Enhanced Permission Checking**
```javascript
// New methods in PData.js
hasRole(username, rolePattern) {
    const userRoles = this.getUserRoles(username);
    if (rolePattern.includes('*')) {
        const pattern = rolePattern.replace('*', '.*');
        return userRoles.some(role => new RegExp(pattern).test(role));
    }
    return userRoles.includes(rolePattern);
}

hasAnyRole(username, rolePatterns) {
    return rolePatterns.some(pattern => this.hasRole(username, pattern));
}

hasAllRoles(username, rolePatterns) {
    return rolePatterns.every(pattern => this.hasRole(username, pattern));
}
```

### **Practical Examples**
```javascript
// Grant game-specific access
await pdata.addUserRole('alice', 'game-zelda');
await pdata.addUserRole('alice', 'write-games/zelda/*');

// Check permissions
if (pdata.hasRole('alice', 'game-zelda')) {
    // Alice can access Zelda game content
}

if (pdata.hasRole('alice', 'write-games/zelda/*')) {
    // Alice can edit Zelda game files
}
```

---

## **2. Plan 9 File System Concepts**

### **Plan 9 Permission Model Overview**
Plan 9 uses a **capability-based** system where:
- **9P protocol**: Network-transparent file access
- **Namespace per process**: Each process has its own view of the filesystem
- **Mount points**: Bind services/directories at arbitrary paths
- **Authentication files**: Special files that grant access tokens

### **Key Plan 9 Concepts to Adopt**

#### **A. Capability Tokens**
```javascript
// Plan 9 style: Each token grants specific capabilities
const token = {
    id: 'tok_abc123',
    username: 'alice',
    capabilities: [
        'read:/games/zelda',
        'write:/games/zelda/saves', 
        'list:/projects',
        'execute:/tools/compiler'
    ],
    expires: Date.now() + (7 * 24 * 60 * 60 * 1000), // 7 days
    namespace: '/restricted' // Root path for this token
};
```

#### **B. Namespace Binding**
```javascript
// Each user/token gets a custom filesystem view
const namespaces = {
    'alice': {
        '/games': '/data/projects/games',      // Alice sees games at /games
        '/tools': '/data/shared/tools',        // Shared tools
        '/private': '/data/users/alice'        // Her private space
    },
    'token_abc123': {
        '/': '/data/projects/zelda',           // Token-scoped root
        '/shared': '/data/shared/assets'       // Limited shared access
    }
};
```

#### **C. Special Permission Files**
```javascript
// Plan 9 has special files like /dev/cons, /proc/*/ctl
// We could have:
'/api/auth/capabilities'  // Shows current user's capabilities
'/api/auth/tokens'        // Manage tokens  
'/api/perms/*/grant'      // Grant permissions to path
'/api/perms/*/revoke'     // Revoke permissions
```

---

## **3. Enhanced PData Implementation**

### **Enhanced Token System**
```javascript
// New TokenManager class
class TokenManager {
    generateToken(username, capabilities, options = {}) {
        const token = crypto.randomBytes(32).toString('hex');
        const tokenData = {
            username,
            capabilities: this.validateCapabilities(capabilities),
            namespace: options.namespace || '/',
            expiresAt: Date.now() + (options.ttl || TOKEN_EXPIRY_MS),
            createdAt: Date.now(),
            description: options.description || 'API Access Token'
        };
        
        this.tokenStore.set(token, tokenData);
        return { token, ...tokenData };
    }
    
    validateCapabilities(capabilities) {
        // Validate each capability against user's actual permissions
        return capabilities.filter(cap => this.isValidCapability(cap));
    }
    
    hasCapability(token, action, path) {
        const tokenData = this.tokenStore.get(token);
        if (!tokenData || tokenData.expiresAt < Date.now()) return false;
        
        return tokenData.capabilities.some(cap => {
            const [capAction, capPath] = cap.split(':');
            return this.matchesCapability(action, path, capAction, capPath);
        });
    }
}
```

### **Enhanced PathManager with Namespaces**
```javascript
class PathManager {
    async resolvePathForToken(token, inputPath) {
        const tokenData = this.tokenManager.validateApiToken(token);
        if (!tokenData) throw new Error('Invalid token');
        
        // Apply token's namespace
        const namespacedPath = path.join(tokenData.namespace, inputPath);
        
        // Check capability
        if (!this.tokenManager.hasCapability(token, 'read', namespacedPath)) {
            throw new Error('Token lacks capability for this path');
        }
        
        return this.resolveActualPath(namespacedPath);
    }
    
    async can(subject, action, resourcePath) {
        // subject can be username or token
        if (subject.startsWith('tok_')) {
            return this.tokenManager.hasCapability(subject, action, resourcePath);
        }
        
        // Original user-based permission checking with enhanced roles
        return this.canUserAccess(subject, action, resourcePath);
    }
}
```

### **Share Token Generation**
```javascript
// Generate shareable tokens for specific content
router.post('/api/auth/share', authMiddleware, async (req, res) => {
    const { path, permissions, expires } = req.body;
    
    // Check if user can share this path
    if (!await req.pdata.pathManager.can(req.user.username, 'share', path)) {
        return res.status(403).json({ error: 'Cannot share this resource' });
    }
    
    // Generate limited capability token
    const capabilities = permissions.map(p => `${p}:${path}`);
    const shareToken = req.pdata.tokenManager.generateToken(
        `share:${req.user.username}`, 
        capabilities,
        { 
            ttl: expires || (7 * 24 * 60 * 60 * 1000), // 7 days default
            namespace: path,
            description: `Shared by ${req.user.username}`
        }
    );
    
    res.json({
        token: shareToken.token,
        shareUrl: `/share/${shareToken.token}`,
        expires: shareToken.expiresAt,
        capabilities
    });
});
```

---

## **4. Implementation Roadmap**

### **Phase 1: Enhanced Role System**
1. **Update role checking logic** - Use arrays instead of single role
2. **Add pattern matching** - Support `game-*`, `write-*` patterns  
3. **Role categories** - System/Functional/Context/Permission classification
4. **Migration script** - Convert existing single roles to arrays

### **Phase 2: Capability Tokens**
1. **TokenManager class** - Separate token logic from auth middleware
2. **Capability validation** - Check token permissions against resources
3. **Namespace support** - Token-scoped filesystem views
4. **Share token API** - Generate limited-scope sharing tokens

### **Phase 3: Plan 9 Inspired Features**
1. **Special API endpoints** - `/api/auth/capabilities`, `/api/perms/*`
2. **Per-user namespaces** - Custom filesystem views per user/token
3. **Mount point simulation** - Bind different data sources at custom paths
4. **Resource descriptors** - Plan 9 style resource identification

### **Phase 4: Advanced Features**
1. **Delegated permissions** - Users can grant sub-permissions to others
2. **Audit logging** - Track all permission grants/revokes
3. **Permission inheritance** - Directory permissions cascade to children
4. **Time-based permissions** - Temporary access with auto-expiry

Would you like me to start implementing any of these phases? I'd recommend starting with **Phase 1** (enhanced role system) since it builds on your existing infrastructure and provides immediate benefits.