"use strict";exports.createLogger=function(t={}){const{collapsed:e=!0,duration:o=!1,timestamp:r=!0,colors:n=!0}=t;return({getState:t})=>e=>n=>{const i=t(),c=Date.now();console.groupCollapsed?console.groupCollapsed(`[StateKitLite] ${n.type}`):console.group(`[StateKitLite] ${n.type}`),r&&console.log("Time:",(new Date).toISOString()),console.log("Prev State:",i),console.log("Action:",n);const a=e(n),s=t(),l=Date.now();return o&&console.log("Duration:",l-c+"ms"),console.log("Next State:",s),console.groupEnd(),a}},exports.createStore=function(t,e,o=[]){let r={...e};const n=new Set;let i=!1;function c(){return r}function a(e){if(function(t){if(null==t)throw new Error("Actions may not be null or undefined");if("object"!=typeof t)throw new Error("Actions must be plain objects");if(void 0===t.type)throw new Error('Actions may not have an undefined "type" property');try{JSON.stringify(t)}catch(t){throw new Error("Actions must be serializable")}}(e),i)throw new Error("Reducers may not dispatch actions");try{i=!0;const o=r,c=t(r,e);c!==o&&(console.debug("[StateKitLite] State updating DEBUG]",{action:e.type,prevState:o,newState:c}),r=c,n.forEach(t=>{try{t(r,o,e)}catch(t){console.error("[StateKitLite] Listener error:",t)}}))}catch(t){throw console.error("[StateKitLite] Reducer error:",t),t}finally{i=!1}}function s(t){const e=o.map(t=>t({getState:c,dispatch:s}));return e.reduce((t,e)=>(...o)=>t(e(...o)),a)(t)}return s({type:"@@INIT"}),console.log("[StateKitLite] New store created with initial state:",r),{getState:c,dispatch:s,subscribe:function(t){if("function"!=typeof t)throw new Error("Expected the listener to be a function");return n.add(t),()=>{n.delete(t)}}}};
