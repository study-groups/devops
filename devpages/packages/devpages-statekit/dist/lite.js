"use strict";exports.createLogger=function(t={}){const{collapsed:e=!0,duration:o=!1,timestamp:n=!0,colors:r=!0,excludeActions:i=[]}=t;return({getState:t})=>e=>r=>{if(i.includes(r.type))return e(r);const c=t(),a=Date.now();console.groupCollapsed?console.groupCollapsed(`[StateKitLite] ${r.type}`):console.group(`[StateKitLite] ${r.type}`),n&&console.log("Time:",(new Date).toISOString()),console.log("Prev State:",c),console.log("Action:",r);const s=e(r),l=t(),u=Date.now();return o&&console.log("Duration:",u-a+"ms"),console.log("Next State:",l),console.groupEnd(),s}},exports.createStore=function(t,e,o=[]){let n={...e};const r=new Set;let i=!1;function c(){return n}function a(e){if(function(t){if(null==t)throw new Error("Actions may not be null or undefined");if("object"!=typeof t)throw new Error("Actions must be plain objects");if(void 0===t.type)throw new Error('Actions may not have an undefined "type" property');try{JSON.stringify(t)}catch(t){throw new Error("Actions must be serializable")}}(e),i)throw new Error("Reducers may not dispatch actions");try{i=!0;const o=n,c=t(n,e);c!==o&&("log/addEntry"!==e.type&&"LOG_ADD_ENTRY"!==e.type&&console.debug("[StateKitLite] State updating DEBUG]",{action:e.type,prevState:o,newState:c}),n=c,r.forEach(t=>{try{t(n,o,e)}catch(t){console.error("[StateKitLite] Listener error:",t)}}))}catch(t){throw console.error("[StateKitLite] Reducer error:",t),t}finally{i=!1}}function s(t){const e=o.map(t=>t({getState:c,dispatch:s}));return e.reduce((t,e)=>(...o)=>t(e(...o)),a)(t)}return s({type:"@@INIT"}),console.log("[StateKitLite] New store created with initial state:",n),{getState:c,dispatch:s,subscribe:function(t){if("function"!=typeof t)throw new Error("Expected the listener to be a function");return r.add(t),()=>{r.delete(t)}}}};
