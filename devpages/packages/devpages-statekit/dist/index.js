"use strict";exports.createLogger=function(t={}){const{collapsed:e=!0,duration:o=!1,timestamp:n=!0,colors:r=!0}=t;return({getState:t})=>e=>r=>{const c=t(),i=Date.now();console.groupCollapsed?console.groupCollapsed(`[StateKit] ${r.type}`):console.group(`[StateKit] ${r.type}`),n&&console.log("Time:",(new Date).toISOString()),console.log("Prev State:",c),console.log("Action:",r);const a=e(r),s=t(),l=Date.now();return o&&console.log("Duration:",l-i+"ms"),console.log("Next State:",s),console.groupEnd(),a}},exports.createStore=function(t,e,o=[]){let n={...e};const r=new Set;let c=!1;function i(){return n}function a(e){if(function(t){if(null==t)throw new Error("Actions may not be null or undefined");if("object"!=typeof t)throw new Error("Actions must be plain objects");if(void 0===t.type)throw new Error('Actions may not have an undefined "type" property');try{JSON.stringify(t)}catch(t){throw new Error("Actions must be serializable")}}(e),c)throw new Error("Reducers may not dispatch actions");try{c=!0;const o=n,i=t(n,e);i!==o&&(console.debug("[StateKit] State updating DEBUG]",{action:e.type,prevState:o,newState:i}),n=i,r.forEach(t=>{try{t(n,o,e)}catch(t){console.error("[StateKit] Listener error:",t)}}))}catch(t){throw console.error("[StateKit] Reducer error:",t),t}finally{c=!1}}function s(t){const e=o.map(t=>t({getState:i,dispatch:s}));return e.reduce((t,e)=>(...o)=>t(e(...o)))(a)(t)}return s({type:"@@INIT"}),console.log("[StateKit] New store created with initial state:",n),{getState:i,dispatch:s,subscribe:function(t){if("function"!=typeof t)throw new Error("Expected the listener to be a function");return r.add(t),()=>{r.delete(t)}}}},exports.createThunk=function(){return({dispatch:t,getState:e})=>o=>n=>"function"==typeof n?n(t,e):o(n)};
