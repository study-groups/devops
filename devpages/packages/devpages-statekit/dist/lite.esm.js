function t(t,e,o=[]){let n={...e};const r=new Set;let i=!1;function c(){return n}function a(e){if(function(t){if(null==t)throw new Error("Actions may not be null or undefined");if("object"!=typeof t)throw new Error("Actions must be plain objects");if(void 0===t.type)throw new Error('Actions may not have an undefined "type" property');try{JSON.stringify(t)}catch(t){throw new Error("Actions must be serializable")}}(e),i)throw new Error("Reducers may not dispatch actions");try{i=!0;const o=n,c=t(n,e);c!==o&&(console.debug("[StateKitLite] State updating DEBUG]",{action:e.type,prevState:o,newState:c}),n=c,r.forEach(t=>{try{t(n,o,e)}catch(t){console.error("[StateKitLite] Listener error:",t)}}))}catch(t){throw console.error("[StateKitLite] Reducer error:",t),t}finally{i=!1}}function s(t){const e=o.map(t=>t({getState:c,dispatch:s}));return e.reduce((t,e)=>(...o)=>t(e(...o)),a)(t)}return s({type:"@@INIT"}),console.log("[StateKitLite] New store created with initial state:",n),{getState:c,dispatch:s,subscribe:function(t){if("function"!=typeof t)throw new Error("Expected the listener to be a function");return r.add(t),()=>{r.delete(t)}}}}function e(t={}){const{collapsed:e=!0,duration:o=!1,timestamp:n=!0,colors:r=!0}=t;return({getState:t})=>e=>r=>{const i=t(),c=Date.now();console.groupCollapsed?console.groupCollapsed(`[StateKitLite] ${r.type}`):console.group(`[StateKitLite] ${r.type}`),n&&console.log("Time:",(new Date).toISOString()),console.log("Prev State:",i),console.log("Action:",r);const a=e(r),s=t(),l=Date.now();return o&&console.log("Duration:",l-c+"ms"),console.log("Next State:",s),console.groupEnd(),a}}export{e as createLogger,t as createStore};
