// client/cli/handlers.js - Updated to handle object payload

import EventBus from '../eventBus.js';
import { CLI_EVENTS } from './cliEvents.js';
import { globalFetch } from '../globalFetch.js';

// Ensure window.logMessage exists or provide a stub
if (typeof window !== 'undefined' && typeof window.logMessage === 'undefined') {
    console.warn('Stubbing window.logMessage for CLI handlers.');
    window.logMessage = (message, type) => {
        const logType = type === 'error' ? 'error' : (type === 'warning' ? 'warn' : 'log');
        console[logType](message);
    };
}

/**
 * Executes a command remotely via the server API.
 * @param {object} payload - The payload object generated by handleSendCommand.
 * @returns {Promise<string>} The output from the command execution.
 */
export async function executeRemoteCommand(payload) {
    console.log('[Remote Handler] executeRemoteCommand CALLED.');
    console.log('[Remote Handler] Payload RECEIVED (stringified immediately):', JSON.stringify(payload));
    console.log('[Remote Handler] executeRemoteCommand called with payload (direct object log):', payload);

    // Basic validation - ensure it's an object (could be more specific if needed)
    if (typeof payload !== 'object' || payload === null) {
        const errorMsg = '[Remote Handler] Invalid payload format received (not an object).';
        console.error(errorMsg, payload);
        window.logMessage(errorMsg, 'error');
        throw new Error('Invalid payload format for remote command execution (internal client error).');
    }

    // Determine command for logging/events (might be in command or qa_alias)
    const commandForLog = payload.command || payload.qa_alias || '[unknown command]';

    window.logMessage(`[CLI] Sending to server: ${commandForLog}...`);
    EventBus.emit(CLI_EVENTS.COMMAND_PROCESSING, { command: commandForLog, timestamp: Date.now() });

    console.log('[Remote Handler] Sending stringified payload (before fetch):', JSON.stringify(payload));

    try {
        const response = await globalFetch('/api/cli', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload) // Send the whole payload object
        });

        console.log(`[Remote Handler] Response status: ${response.status}`);

        // Check content type before parsing
        const contentType = response.headers.get('content-type');
        if (!response.ok || !contentType || !contentType.includes('application/json')) {
            let errorText = `Server error (${response.status})`;
            try {
                // Try to get text for logging, even if not JSON
                const textResponse = await response.text();
                console.error('[Remote Handler] Non-JSON or Error Response Body:', textResponse);
                // Use a snippet if it's long HTML
                errorText = result.output || result.error || `Server error (${response.status}): ${textResponse.substring(0, 100)}...`;
            } catch (_) { /* Ignore secondary error getting text */ }

            // Use the existing error handling logic
            console.error('[Remote Handler] API Error Response (or non-JSON response)');
            window.logMessage(`[SERVER ERROR] ${errorText}`, 'error');
            throw new Error(errorText); // Throw the more informative error
        }

        // If we get here, it should be a valid JSON response
        const result = await response.json();
        console.log('[Remote Handler] API Success Response:', result);

        // Process output, splitting STDERR
        const outputFromServer = result.output || '';
        const lines = outputFromServer.split('\n');
        let stdoutBuffer = [];
        lines.forEach(line => {
            if (line.startsWith('STDERR:')) {
                const stderrMsg = line.substring(7).trim();
                window.logMessage(`[CLI STDERR] ${stderrMsg}`, 'warning');
            } else {
                stdoutBuffer.push(line);
            }
        });
        const finalOutput = stdoutBuffer.join('\n');

        EventBus.emit(CLI_EVENTS.COMMAND_RESPONSE, { command: commandForLog, result: finalOutput, success: true, source: 'server', timestamp: Date.now() });
        EventBus.emit(CLI_EVENTS.COMMAND_EXECUTED, { command: commandForLog, result: finalOutput, success: true, source: 'server', timestamp: Date.now() });

        return finalOutput;

    } catch (error) {
        console.error(`[Remote Handler] Network or processing error for "${commandForLog}":`, error);
        const errorMessage = error?.message || 'Unknown execution error';
        window.logMessage(`[NETWORK/CLIENT ERROR] ${errorMessage}`, 'error');
        EventBus.emit(CLI_EVENTS.COMMAND_ERROR, { command: commandForLog, error: errorMessage, timestamp: Date.now() });
        throw error;
    }
}